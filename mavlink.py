'''
MAVLink protocol implementation (auto-generated by mavgen.py)

Generated from: ardupilotmega.xml

Note: this file has been auto-generated. DO NOT EDIT
'''
from __future__ import print_function
from builtins import range
from builtins import object
import struct, array, time, json, os, sys, platform

from pymavlink.generator.mavcrc import x25crc
import hashlib

WIRE_PROTOCOL_VERSION = '1.0'
DIALECT = 'mavlink'

PROTOCOL_MARKER_V1 = 0xFE
PROTOCOL_MARKER_V2 = 0xFD
HEADER_LEN_V1 = 6
HEADER_LEN_V2 = 10

MAVLINK_SIGNATURE_BLOCK_LEN = 13

MAVLINK_IFLAG_SIGNED = 0x01

native_supported = platform.system() != 'Windows' # Not yet supported on other dialects
native_force = 'MAVNATIVE_FORCE' in os.environ # Will force use of native code regardless of what client app wants
native_testing = 'MAVNATIVE_TESTING' in os.environ # Will force both native and legacy code to be used and their results compared

if native_supported and float(WIRE_PROTOCOL_VERSION) <= 1:
    try:
        import mavnative
    except ImportError:
        print('ERROR LOADING MAVNATIVE - falling back to python implementation')
        native_supported = False
else:
    # mavnative isn't supported for MAVLink2 yet
    native_supported = False

# some base types from mavlink_types.h
MAVLINK_TYPE_CHAR     = 0
MAVLINK_TYPE_UINT8_T  = 1
MAVLINK_TYPE_INT8_T   = 2
MAVLINK_TYPE_UINT16_T = 3
MAVLINK_TYPE_INT16_T  = 4
MAVLINK_TYPE_UINT32_T = 5
MAVLINK_TYPE_INT32_T  = 6
MAVLINK_TYPE_UINT64_T = 7
MAVLINK_TYPE_INT64_T  = 8
MAVLINK_TYPE_FLOAT    = 9
MAVLINK_TYPE_DOUBLE   = 10


class MAVLink_header(object):
    '''MAVLink message header'''
    def __init__(self, msgId, incompat_flags=0, compat_flags=0, mlen=0, seq=0, srcSystem=0, srcComponent=0):
        self.mlen = mlen
        self.seq = seq
        self.srcSystem = srcSystem
        self.srcComponent = srcComponent
        self.msgId = msgId
        self.incompat_flags = incompat_flags
        self.compat_flags = compat_flags

    def pack(self, force_mavlink1=False):
        if WIRE_PROTOCOL_VERSION == '2.0' and not force_mavlink1:
            return struct.pack('<BBBBBBBHB', 254, self.mlen,
                               self.incompat_flags, self.compat_flags,
                               self.seq, self.srcSystem, self.srcComponent,
                               self.msgId&0xFFFF, self.msgId>>16)
        return struct.pack('<BBBBBB', PROTOCOL_MARKER_V1, self.mlen, self.seq,
                           self.srcSystem, self.srcComponent, self.msgId)

class MAVLink_message(object):
    '''base MAVLink message class'''
    def __init__(self, msgId, name):
        self._header     = MAVLink_header(msgId)
        self._payload    = None
        self._msgbuf     = None
        self._crc        = None
        self._fieldnames = []
        self._type       = name
        self._signed     = False
        self._link_id    = None
        self._instances  = None
        self._instance_field = None

    # swiped from DFReader.py
    def to_string(self, s):
        '''desperate attempt to convert a string regardless of what garbage we get'''
        try:
            return s.decode("utf-8")
        except Exception as e:
            pass
        try:
            s2 = s.encode('utf-8', 'ignore')
            x = u"%s" % s2
            return s2
        except Exception:
            pass
        # so its a nasty one. Let's grab as many characters as we can
        r = ''
        while s != '':
            try:
                r2 = r + s[0]
                s = s[1:]
                r2 = r2.encode('ascii', 'ignore')
                x = u"%s" % r2
                r = r2
            except Exception:
                break
        return r + '_XXX'

    def format_attr(self, field):
        '''override field getter'''
        raw_attr = getattr(self,field)
        if isinstance(raw_attr, bytes):
            raw_attr = self.to_string(raw_attr).rstrip("\00")
        return raw_attr

    def get_msgbuf(self):
        if isinstance(self._msgbuf, bytearray):
            return self._msgbuf
        return bytearray(self._msgbuf)

    def get_header(self):
        return self._header

    def get_payload(self):
        return self._payload

    def get_crc(self):
        return self._crc

    def get_fieldnames(self):
        return self._fieldnames

    def get_type(self):
        return self._type

    def get_msgId(self):
        return self._header.msgId

    def get_srcSystem(self):
        return self._header.srcSystem

    def get_srcComponent(self):
        return self._header.srcComponent

    def get_seq(self):
        return self._header.seq

    def get_signed(self):
        return self._signed

    def get_link_id(self):
        return self._link_id

    def __str__(self):
        ret = '%s {' % self._type
        for a in self._fieldnames:
            v = self.format_attr(a)
            ret += '%s : %s, ' % (a, v)
        ret = ret[0:-2] + '}'
        return ret

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other is None:
            return False

        if self.get_type() != other.get_type():
            return False

        # We do not compare CRC because native code doesn't provide it
        #if self.get_crc() != other.get_crc():
        #    return False

        if self.get_seq() != other.get_seq():
            return False

        if self.get_srcSystem() != other.get_srcSystem():
            return False

        if self.get_srcComponent() != other.get_srcComponent():
            return False

        for a in self._fieldnames:
            if self.format_attr(a) != other.format_attr(a):
                return False

        return True

    def to_dict(self):
        d = dict({})
        d['mavpackettype'] = self._type
        for a in self._fieldnames:
          d[a] = self.format_attr(a)
        return d

    def to_json(self):
        return json.dumps(self.to_dict())

    def sign_packet(self, mav):
        h = hashlib.new('sha256')
        self._msgbuf += struct.pack('<BQ', mav.signing.link_id, mav.signing.timestamp)[:7]
        h.update(mav.signing.secret_key)
        h.update(self._msgbuf)
        sig = h.digest()[:6]
        self._msgbuf += sig
        mav.signing.timestamp += 1

    def pack(self, mav, crc_extra, payload, force_mavlink1=False):
        plen = len(payload)
        if WIRE_PROTOCOL_VERSION != '1.0' and not force_mavlink1:
            # in MAVLink2 we can strip trailing zeros off payloads. This allows for simple
            # variable length arrays and smaller packets
            nullbyte = chr(0)
            # in Python2, type("fred') is str but also type("fred")==bytes
            if str(type(payload)) == "<class 'bytes'>":
                nullbyte = 0
            while plen > 1 and payload[plen-1] == nullbyte:
                plen -= 1
        self._payload = payload[:plen]
        incompat_flags = 0
        if mav.signing.sign_outgoing:
            incompat_flags |= MAVLINK_IFLAG_SIGNED
        self._header  = MAVLink_header(self._header.msgId,
                                       incompat_flags=incompat_flags, compat_flags=0,
                                       mlen=len(self._payload), seq=mav.seq,
                                       srcSystem=mav.srcSystem, srcComponent=mav.srcComponent)
        self._msgbuf = self._header.pack(force_mavlink1=force_mavlink1) + self._payload
        crc = x25crc(self._msgbuf[1:])
        if True: # using CRC extra
            crc.accumulate_str(struct.pack('B', crc_extra))
        self._crc = crc.crc
        self._msgbuf += struct.pack('<H', self._crc)
        if mav.signing.sign_outgoing and not force_mavlink1:
            self.sign_packet(mav)
        return self._msgbuf

    def __getitem__(self, key):
        '''support indexing, allowing for multi-instance sensors in one message'''
        if self._instances is None:
            raise IndexError()
        if not key in self._instances:
            raise IndexError()
        return self._instances[key]


# enums

class EnumEntry(object):
    def __init__(self, name, description):
        self.name = name
        self.description = description
        self.param = {}

enums = {}

# ACCELCAL_VEHICLE_POS
enums['ACCELCAL_VEHICLE_POS'] = {}
ACCELCAL_VEHICLE_POS_LEVEL = 1 # 
enums['ACCELCAL_VEHICLE_POS'][1] = EnumEntry('ACCELCAL_VEHICLE_POS_LEVEL', '''''')
ACCELCAL_VEHICLE_POS_LEFT = 2 # 
enums['ACCELCAL_VEHICLE_POS'][2] = EnumEntry('ACCELCAL_VEHICLE_POS_LEFT', '''''')
ACCELCAL_VEHICLE_POS_RIGHT = 3 # 
enums['ACCELCAL_VEHICLE_POS'][3] = EnumEntry('ACCELCAL_VEHICLE_POS_RIGHT', '''''')
ACCELCAL_VEHICLE_POS_NOSEDOWN = 4 # 
enums['ACCELCAL_VEHICLE_POS'][4] = EnumEntry('ACCELCAL_VEHICLE_POS_NOSEDOWN', '''''')
ACCELCAL_VEHICLE_POS_NOSEUP = 5 # 
enums['ACCELCAL_VEHICLE_POS'][5] = EnumEntry('ACCELCAL_VEHICLE_POS_NOSEUP', '''''')
ACCELCAL_VEHICLE_POS_BACK = 6 # 
enums['ACCELCAL_VEHICLE_POS'][6] = EnumEntry('ACCELCAL_VEHICLE_POS_BACK', '''''')
ACCELCAL_VEHICLE_POS_SUCCESS = 16777215 # 
enums['ACCELCAL_VEHICLE_POS'][16777215] = EnumEntry('ACCELCAL_VEHICLE_POS_SUCCESS', '''''')
ACCELCAL_VEHICLE_POS_FAILED = 16777216 # 
enums['ACCELCAL_VEHICLE_POS'][16777216] = EnumEntry('ACCELCAL_VEHICLE_POS_FAILED', '''''')
ACCELCAL_VEHICLE_POS_ENUM_END = 16777217 # 
enums['ACCELCAL_VEHICLE_POS'][16777217] = EnumEntry('ACCELCAL_VEHICLE_POS_ENUM_END', '''''')

# MAV_CMD
enums['MAV_CMD'] = {}
MAV_CMD_NAV_ALTITUDE_WAIT = 83 # Mission command to wait for an altitude or downwards vertical speed.
                        # This is meant for high altitude balloon
                        # launches, allowing the aircraft to be idle
                        # until either an altitude is reached or a
                        # negative vertical speed is reached
                        # (indicating early balloon burst). The wiggle
                        # time is how often to wiggle the control
                        # surfaces to prevent them seizing up.
enums['MAV_CMD'][83] = EnumEntry('MAV_CMD_NAV_ALTITUDE_WAIT', '''Mission command to wait for an altitude or downwards vertical speed. This is meant for high altitude balloon launches, allowing the aircraft to be idle until either an altitude is reached or a negative vertical speed is reached (indicating early balloon burst). The wiggle time is how often to wiggle the control surfaces to prevent them seizing up.''')
enums['MAV_CMD'][83].param[1] = '''Altitude (m).'''
enums['MAV_CMD'][83].param[2] = '''Descent speed (m/s).'''
enums['MAV_CMD'][83].param[3] = '''Wiggle Time (s).'''
enums['MAV_CMD'][83].param[4] = '''Empty.'''
enums['MAV_CMD'][83].param[5] = '''Empty.'''
enums['MAV_CMD'][83].param[6] = '''Empty.'''
enums['MAV_CMD'][83].param[7] = '''Empty.'''
MAV_CMD_DO_GRIPPER = 211 # Mission command to operate EPM gripper.
enums['MAV_CMD'][211] = EnumEntry('MAV_CMD_DO_GRIPPER', '''Mission command to operate EPM gripper.''')
enums['MAV_CMD'][211].param[1] = '''Gripper number (a number from 1 to max number of grippers on the vehicle).'''
enums['MAV_CMD'][211].param[2] = '''Gripper action (0=release, 1=grab. See GRIPPER_ACTIONS enum).'''
enums['MAV_CMD'][211].param[3] = '''Empty.'''
enums['MAV_CMD'][211].param[4] = '''Empty.'''
enums['MAV_CMD'][211].param[5] = '''Empty.'''
enums['MAV_CMD'][211].param[6] = '''Empty.'''
enums['MAV_CMD'][211].param[7] = '''Empty.'''
MAV_CMD_DO_AUTOTUNE_ENABLE = 212 # Enable/disable autotune.
enums['MAV_CMD'][212] = EnumEntry('MAV_CMD_DO_AUTOTUNE_ENABLE', '''Enable/disable autotune.''')
enums['MAV_CMD'][212].param[1] = '''Enable (1: enable, 0:disable).'''
enums['MAV_CMD'][212].param[2] = '''Empty.'''
enums['MAV_CMD'][212].param[3] = '''Empty.'''
enums['MAV_CMD'][212].param[4] = '''Empty.'''
enums['MAV_CMD'][212].param[5] = '''Empty.'''
enums['MAV_CMD'][212].param[6] = '''Empty.'''
enums['MAV_CMD'][212].param[7] = '''Empty.'''
MAV_CMD_DO_SET_RESUME_REPEAT_DIST = 215 # Set the distance to be repeated on mission resume
enums['MAV_CMD'][215] = EnumEntry('MAV_CMD_DO_SET_RESUME_REPEAT_DIST', '''Set the distance to be repeated on mission resume''')
enums['MAV_CMD'][215].param[1] = '''Distance.'''
enums['MAV_CMD'][215].param[2] = '''Empty.'''
enums['MAV_CMD'][215].param[3] = '''Empty.'''
enums['MAV_CMD'][215].param[4] = '''Empty.'''
enums['MAV_CMD'][215].param[5] = '''Empty.'''
enums['MAV_CMD'][215].param[6] = '''Empty.'''
enums['MAV_CMD'][215].param[7] = '''Empty.'''
MAV_CMD_POWER_OFF_INITIATED = 42000 # A system wide power-off event has been initiated.
enums['MAV_CMD'][42000] = EnumEntry('MAV_CMD_POWER_OFF_INITIATED', '''A system wide power-off event has been initiated.''')
enums['MAV_CMD'][42000].param[1] = '''Empty.'''
enums['MAV_CMD'][42000].param[2] = '''Empty.'''
enums['MAV_CMD'][42000].param[3] = '''Empty.'''
enums['MAV_CMD'][42000].param[4] = '''Empty.'''
enums['MAV_CMD'][42000].param[5] = '''Empty.'''
enums['MAV_CMD'][42000].param[6] = '''Empty.'''
enums['MAV_CMD'][42000].param[7] = '''Empty.'''
MAV_CMD_SOLO_BTN_FLY_CLICK = 42001 # FLY button has been clicked.
enums['MAV_CMD'][42001] = EnumEntry('MAV_CMD_SOLO_BTN_FLY_CLICK', '''FLY button has been clicked.''')
enums['MAV_CMD'][42001].param[1] = '''Empty.'''
enums['MAV_CMD'][42001].param[2] = '''Empty.'''
enums['MAV_CMD'][42001].param[3] = '''Empty.'''
enums['MAV_CMD'][42001].param[4] = '''Empty.'''
enums['MAV_CMD'][42001].param[5] = '''Empty.'''
enums['MAV_CMD'][42001].param[6] = '''Empty.'''
enums['MAV_CMD'][42001].param[7] = '''Empty.'''
MAV_CMD_SOLO_BTN_FLY_HOLD = 42002 # FLY button has been held for 1.5 seconds.
enums['MAV_CMD'][42002] = EnumEntry('MAV_CMD_SOLO_BTN_FLY_HOLD', '''FLY button has been held for 1.5 seconds.''')
enums['MAV_CMD'][42002].param[1] = '''Takeoff altitude.'''
enums['MAV_CMD'][42002].param[2] = '''Empty.'''
enums['MAV_CMD'][42002].param[3] = '''Empty.'''
enums['MAV_CMD'][42002].param[4] = '''Empty.'''
enums['MAV_CMD'][42002].param[5] = '''Empty.'''
enums['MAV_CMD'][42002].param[6] = '''Empty.'''
enums['MAV_CMD'][42002].param[7] = '''Empty.'''
MAV_CMD_SOLO_BTN_PAUSE_CLICK = 42003 # PAUSE button has been clicked.
enums['MAV_CMD'][42003] = EnumEntry('MAV_CMD_SOLO_BTN_PAUSE_CLICK', '''PAUSE button has been clicked.''')
enums['MAV_CMD'][42003].param[1] = '''1 if Solo is in a shot mode, 0 otherwise.'''
enums['MAV_CMD'][42003].param[2] = '''Empty.'''
enums['MAV_CMD'][42003].param[3] = '''Empty.'''
enums['MAV_CMD'][42003].param[4] = '''Empty.'''
enums['MAV_CMD'][42003].param[5] = '''Empty.'''
enums['MAV_CMD'][42003].param[6] = '''Empty.'''
enums['MAV_CMD'][42003].param[7] = '''Empty.'''
MAV_CMD_FIXED_MAG_CAL = 42004 # Magnetometer calibration based on fixed position         in earth
                        # field given by inclination, declination and
                        # intensity.
enums['MAV_CMD'][42004] = EnumEntry('MAV_CMD_FIXED_MAG_CAL', '''Magnetometer calibration based on fixed position
        in earth field given by inclination, declination and intensity.''')
enums['MAV_CMD'][42004].param[1] = '''MagDeclinationDegrees.'''
enums['MAV_CMD'][42004].param[2] = '''MagInclinationDegrees.'''
enums['MAV_CMD'][42004].param[3] = '''MagIntensityMilliGauss.'''
enums['MAV_CMD'][42004].param[4] = '''YawDegrees.'''
enums['MAV_CMD'][42004].param[5] = '''Empty.'''
enums['MAV_CMD'][42004].param[6] = '''Empty.'''
enums['MAV_CMD'][42004].param[7] = '''Empty.'''
MAV_CMD_FIXED_MAG_CAL_FIELD = 42005 # Magnetometer calibration based on fixed expected field values in
                        # milliGauss.
enums['MAV_CMD'][42005] = EnumEntry('MAV_CMD_FIXED_MAG_CAL_FIELD', '''Magnetometer calibration based on fixed expected field values in milliGauss.''')
enums['MAV_CMD'][42005].param[1] = '''FieldX.'''
enums['MAV_CMD'][42005].param[2] = '''FieldY.'''
enums['MAV_CMD'][42005].param[3] = '''FieldZ.'''
enums['MAV_CMD'][42005].param[4] = '''Empty.'''
enums['MAV_CMD'][42005].param[5] = '''Empty.'''
enums['MAV_CMD'][42005].param[6] = '''Empty.'''
enums['MAV_CMD'][42005].param[7] = '''Empty.'''
MAV_CMD_FIXED_MAG_CAL_YAW = 42006 # Magnetometer calibration based on provided known yaw. This allows for
                        # fast calibration using WMM field tables in
                        # the vehicle, given only the known yaw of the
                        # vehicle. If Latitude and longitude are both
                        # zero then use the current vehicle location.
enums['MAV_CMD'][42006] = EnumEntry('MAV_CMD_FIXED_MAG_CAL_YAW', '''Magnetometer calibration based on provided known yaw. This allows for fast calibration using WMM field tables in the vehicle, given only the known yaw of the vehicle. If Latitude and longitude are both zero then use the current vehicle location.''')
enums['MAV_CMD'][42006].param[1] = '''Yaw of vehicle in earth frame.'''
enums['MAV_CMD'][42006].param[2] = '''CompassMask, 0 for all.'''
enums['MAV_CMD'][42006].param[3] = '''Latitude.'''
enums['MAV_CMD'][42006].param[4] = '''Longitude.'''
enums['MAV_CMD'][42006].param[5] = '''Empty.'''
enums['MAV_CMD'][42006].param[6] = '''Empty.'''
enums['MAV_CMD'][42006].param[7] = '''Empty.'''
MAV_CMD_DO_START_MAG_CAL = 42424 # Initiate a magnetometer calibration.
enums['MAV_CMD'][42424] = EnumEntry('MAV_CMD_DO_START_MAG_CAL', '''Initiate a magnetometer calibration.''')
enums['MAV_CMD'][42424].param[1] = '''uint8_t bitmask of magnetometers (0 means all).'''
enums['MAV_CMD'][42424].param[2] = '''Automatically retry on failure (0=no retry, 1=retry).'''
enums['MAV_CMD'][42424].param[3] = '''Save without user input (0=require input, 1=autosave).'''
enums['MAV_CMD'][42424].param[4] = '''Delay (seconds).'''
enums['MAV_CMD'][42424].param[5] = '''Autoreboot (0=user reboot, 1=autoreboot).'''
enums['MAV_CMD'][42424].param[6] = '''Empty.'''
enums['MAV_CMD'][42424].param[7] = '''Empty.'''
MAV_CMD_DO_ACCEPT_MAG_CAL = 42425 # Initiate a magnetometer calibration.
enums['MAV_CMD'][42425] = EnumEntry('MAV_CMD_DO_ACCEPT_MAG_CAL', '''Initiate a magnetometer calibration.''')
enums['MAV_CMD'][42425].param[1] = '''uint8_t bitmask of magnetometers (0 means all).'''
enums['MAV_CMD'][42425].param[2] = '''Empty.'''
enums['MAV_CMD'][42425].param[3] = '''Empty.'''
enums['MAV_CMD'][42425].param[4] = '''Empty.'''
enums['MAV_CMD'][42425].param[5] = '''Empty.'''
enums['MAV_CMD'][42425].param[6] = '''Empty.'''
enums['MAV_CMD'][42425].param[7] = '''Empty.'''
MAV_CMD_DO_CANCEL_MAG_CAL = 42426 # Cancel a running magnetometer calibration.
enums['MAV_CMD'][42426] = EnumEntry('MAV_CMD_DO_CANCEL_MAG_CAL', '''Cancel a running magnetometer calibration.''')
enums['MAV_CMD'][42426].param[1] = '''uint8_t bitmask of magnetometers (0 means all).'''
enums['MAV_CMD'][42426].param[2] = '''Empty.'''
enums['MAV_CMD'][42426].param[3] = '''Empty.'''
enums['MAV_CMD'][42426].param[4] = '''Empty.'''
enums['MAV_CMD'][42426].param[5] = '''Empty.'''
enums['MAV_CMD'][42426].param[6] = '''Empty.'''
enums['MAV_CMD'][42426].param[7] = '''Empty.'''
MAV_CMD_SET_FACTORY_TEST_MODE = 42427 # Command autopilot to get into factory test/diagnostic mode.
enums['MAV_CMD'][42427] = EnumEntry('MAV_CMD_SET_FACTORY_TEST_MODE', '''Command autopilot to get into factory test/diagnostic mode.''')
enums['MAV_CMD'][42427].param[1] = '''0 means get out of test mode, 1 means get into test mode.'''
enums['MAV_CMD'][42427].param[2] = '''Empty.'''
enums['MAV_CMD'][42427].param[3] = '''Empty.'''
enums['MAV_CMD'][42427].param[4] = '''Empty.'''
enums['MAV_CMD'][42427].param[5] = '''Empty.'''
enums['MAV_CMD'][42427].param[6] = '''Empty.'''
enums['MAV_CMD'][42427].param[7] = '''Empty.'''
MAV_CMD_DO_SEND_BANNER = 42428 # Reply with the version banner.
enums['MAV_CMD'][42428] = EnumEntry('MAV_CMD_DO_SEND_BANNER', '''Reply with the version banner.''')
enums['MAV_CMD'][42428].param[1] = '''Empty.'''
enums['MAV_CMD'][42428].param[2] = '''Empty.'''
enums['MAV_CMD'][42428].param[3] = '''Empty.'''
enums['MAV_CMD'][42428].param[4] = '''Empty.'''
enums['MAV_CMD'][42428].param[5] = '''Empty.'''
enums['MAV_CMD'][42428].param[6] = '''Empty.'''
enums['MAV_CMD'][42428].param[7] = '''Empty.'''
MAV_CMD_ACCELCAL_VEHICLE_POS = 42429 # Used when doing accelerometer calibration. When sent to the GCS tells
                        # it what position to put the vehicle in. When
                        # sent to the vehicle says what position the
                        # vehicle is in.
enums['MAV_CMD'][42429] = EnumEntry('MAV_CMD_ACCELCAL_VEHICLE_POS', '''Used when doing accelerometer calibration. When sent to the GCS tells it what position to put the vehicle in. When sent to the vehicle says what position the vehicle is in.''')
enums['MAV_CMD'][42429].param[1] = '''Position, one of the ACCELCAL_VEHICLE_POS enum values.'''
enums['MAV_CMD'][42429].param[2] = '''Empty.'''
enums['MAV_CMD'][42429].param[3] = '''Empty.'''
enums['MAV_CMD'][42429].param[4] = '''Empty.'''
enums['MAV_CMD'][42429].param[5] = '''Empty.'''
enums['MAV_CMD'][42429].param[6] = '''Empty.'''
enums['MAV_CMD'][42429].param[7] = '''Empty.'''
MAV_CMD_GIMBAL_RESET = 42501 # Causes the gimbal to reset and boot as if it was just powered on.
enums['MAV_CMD'][42501] = EnumEntry('MAV_CMD_GIMBAL_RESET', '''Causes the gimbal to reset and boot as if it was just powered on.''')
enums['MAV_CMD'][42501].param[1] = '''Empty.'''
enums['MAV_CMD'][42501].param[2] = '''Empty.'''
enums['MAV_CMD'][42501].param[3] = '''Empty.'''
enums['MAV_CMD'][42501].param[4] = '''Empty.'''
enums['MAV_CMD'][42501].param[5] = '''Empty.'''
enums['MAV_CMD'][42501].param[6] = '''Empty.'''
enums['MAV_CMD'][42501].param[7] = '''Empty.'''
MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS = 42502 # Reports progress and success or failure of gimbal axis calibration
                        # procedure.
enums['MAV_CMD'][42502] = EnumEntry('MAV_CMD_GIMBAL_AXIS_CALIBRATION_STATUS', '''Reports progress and success or failure of gimbal axis calibration procedure.''')
enums['MAV_CMD'][42502].param[1] = '''Gimbal axis we're reporting calibration progress for.'''
enums['MAV_CMD'][42502].param[2] = '''Current calibration progress for this axis, 0x64=100%.'''
enums['MAV_CMD'][42502].param[3] = '''Status of the calibration.'''
enums['MAV_CMD'][42502].param[4] = '''Empty.'''
enums['MAV_CMD'][42502].param[5] = '''Empty.'''
enums['MAV_CMD'][42502].param[6] = '''Empty.'''
enums['MAV_CMD'][42502].param[7] = '''Empty.'''
MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION = 42503 # Starts commutation calibration on the gimbal.
enums['MAV_CMD'][42503] = EnumEntry('MAV_CMD_GIMBAL_REQUEST_AXIS_CALIBRATION', '''Starts commutation calibration on the gimbal.''')
enums['MAV_CMD'][42503].param[1] = '''Empty.'''
enums['MAV_CMD'][42503].param[2] = '''Empty.'''
enums['MAV_CMD'][42503].param[3] = '''Empty.'''
enums['MAV_CMD'][42503].param[4] = '''Empty.'''
enums['MAV_CMD'][42503].param[5] = '''Empty.'''
enums['MAV_CMD'][42503].param[6] = '''Empty.'''
enums['MAV_CMD'][42503].param[7] = '''Empty.'''
MAV_CMD_GIMBAL_FULL_RESET = 42505 # Erases gimbal application and parameters.
enums['MAV_CMD'][42505] = EnumEntry('MAV_CMD_GIMBAL_FULL_RESET', '''Erases gimbal application and parameters.''')
enums['MAV_CMD'][42505].param[1] = '''Magic number.'''
enums['MAV_CMD'][42505].param[2] = '''Magic number.'''
enums['MAV_CMD'][42505].param[3] = '''Magic number.'''
enums['MAV_CMD'][42505].param[4] = '''Magic number.'''
enums['MAV_CMD'][42505].param[5] = '''Magic number.'''
enums['MAV_CMD'][42505].param[6] = '''Magic number.'''
enums['MAV_CMD'][42505].param[7] = '''Magic number.'''
MAV_CMD_DO_WINCH = 42600 # Command to operate winch.
enums['MAV_CMD'][42600] = EnumEntry('MAV_CMD_DO_WINCH', '''Command to operate winch.''')
enums['MAV_CMD'][42600].param[1] = '''Winch number (0 for the default winch, otherwise a number from 1 to max number of winches on the vehicle).'''
enums['MAV_CMD'][42600].param[2] = '''Action (0=relax, 1=relative length control, 2=rate control. See WINCH_ACTIONS enum.).'''
enums['MAV_CMD'][42600].param[3] = '''Release length (cable distance to unwind in meters, negative numbers to wind in cable).'''
enums['MAV_CMD'][42600].param[4] = '''Release rate (meters/second).'''
enums['MAV_CMD'][42600].param[5] = '''Empty.'''
enums['MAV_CMD'][42600].param[6] = '''Empty.'''
enums['MAV_CMD'][42600].param[7] = '''Empty.'''
MAV_CMD_FLASH_BOOTLOADER = 42650 # Update the bootloader
enums['MAV_CMD'][42650] = EnumEntry('MAV_CMD_FLASH_BOOTLOADER', '''Update the bootloader''')
enums['MAV_CMD'][42650].param[1] = '''Empty'''
enums['MAV_CMD'][42650].param[2] = '''Empty'''
enums['MAV_CMD'][42650].param[3] = '''Empty'''
enums['MAV_CMD'][42650].param[4] = '''Empty'''
enums['MAV_CMD'][42650].param[5] = '''Magic number - set to 290876 to actually flash'''
enums['MAV_CMD'][42650].param[6] = '''Empty'''
enums['MAV_CMD'][42650].param[7] = '''Empty'''
MAV_CMD_BATTERY_RESET = 42651 # Reset battery capacity for batteries that accumulate consumed battery
                        # via integration.
enums['MAV_CMD'][42651] = EnumEntry('MAV_CMD_BATTERY_RESET', '''Reset battery capacity for batteries that accumulate consumed battery via integration.''')
enums['MAV_CMD'][42651].param[1] = '''Bitmask of batteries to reset. Least significant bit is for the first battery.'''
enums['MAV_CMD'][42651].param[2] = '''Battery percentage remaining to set.'''
enums['MAV_CMD'][42651].param[3] = '''Reserved (default:0)'''
enums['MAV_CMD'][42651].param[4] = '''Reserved (default:0)'''
enums['MAV_CMD'][42651].param[5] = '''Reserved (default:0)'''
enums['MAV_CMD'][42651].param[6] = '''Reserved (default:0)'''
enums['MAV_CMD'][42651].param[7] = '''Reserved (default:0)'''
MAV_CMD_DEBUG_TRAP = 42700 # Issue a trap signal to the autopilot process, presumably to enter the
                        # debugger.
enums['MAV_CMD'][42700] = EnumEntry('MAV_CMD_DEBUG_TRAP', '''Issue a trap signal to the autopilot process, presumably to enter the debugger.''')
enums['MAV_CMD'][42700].param[1] = '''Magic number - set to 32451 to actually trap.'''
enums['MAV_CMD'][42700].param[2] = '''Empty.'''
enums['MAV_CMD'][42700].param[3] = '''Empty.'''
enums['MAV_CMD'][42700].param[4] = '''Empty.'''
enums['MAV_CMD'][42700].param[5] = '''Empty.'''
enums['MAV_CMD'][42700].param[6] = '''Empty.'''
enums['MAV_CMD'][42700].param[7] = '''Empty.'''
MAV_CMD_SCRIPTING = 42701 # Control onboard scripting.
enums['MAV_CMD'][42701] = EnumEntry('MAV_CMD_SCRIPTING', '''Control onboard scripting.''')
enums['MAV_CMD'][42701].param[1] = '''Scripting command to execute'''
enums['MAV_CMD'][42701].param[2] = '''Reserved (default:0)'''
enums['MAV_CMD'][42701].param[3] = '''Reserved (default:0)'''
enums['MAV_CMD'][42701].param[4] = '''Reserved (default:0)'''
enums['MAV_CMD'][42701].param[5] = '''Reserved (default:0)'''
enums['MAV_CMD'][42701].param[6] = '''Reserved (default:0)'''
enums['MAV_CMD'][42701].param[7] = '''Reserved (default:0)'''
MAV_CMD_ENUM_END = 42702 # 
enums['MAV_CMD'][42702] = EnumEntry('MAV_CMD_ENUM_END', '''''')

# SCRIPTING_CMD
enums['SCRIPTING_CMD'] = {}
SCRIPTING_CMD_REPL_START = 0 # Start a REPL session.
enums['SCRIPTING_CMD'][0] = EnumEntry('SCRIPTING_CMD_REPL_START', '''Start a REPL session.''')
SCRIPTING_CMD_REPL_STOP = 1 # End a REPL session.
enums['SCRIPTING_CMD'][1] = EnumEntry('SCRIPTING_CMD_REPL_STOP', '''End a REPL session.''')
SCRIPTING_CMD_ENUM_END = 2 # 
enums['SCRIPTING_CMD'][2] = EnumEntry('SCRIPTING_CMD_ENUM_END', '''''')

# LIMITS_STATE
enums['LIMITS_STATE'] = {}
LIMITS_INIT = 0 # Pre-initialization.
enums['LIMITS_STATE'][0] = EnumEntry('LIMITS_INIT', '''Pre-initialization.''')
LIMITS_DISABLED = 1 # Disabled.
enums['LIMITS_STATE'][1] = EnumEntry('LIMITS_DISABLED', '''Disabled.''')
LIMITS_ENABLED = 2 # Checking limits.
enums['LIMITS_STATE'][2] = EnumEntry('LIMITS_ENABLED', '''Checking limits.''')
LIMITS_TRIGGERED = 3 # A limit has been breached.
enums['LIMITS_STATE'][3] = EnumEntry('LIMITS_TRIGGERED', '''A limit has been breached.''')
LIMITS_RECOVERING = 4 # Taking action e.g. Return/RTL.
enums['LIMITS_STATE'][4] = EnumEntry('LIMITS_RECOVERING', '''Taking action e.g. Return/RTL.''')
LIMITS_RECOVERED = 5 # We're no longer in breach of a limit.
enums['LIMITS_STATE'][5] = EnumEntry('LIMITS_RECOVERED', '''We're no longer in breach of a limit.''')
LIMITS_STATE_ENUM_END = 6 # 
enums['LIMITS_STATE'][6] = EnumEntry('LIMITS_STATE_ENUM_END', '''''')

# LIMIT_MODULE
enums['LIMIT_MODULE'] = {}
LIMIT_GPSLOCK = 1 # Pre-initialization.
enums['LIMIT_MODULE'][1] = EnumEntry('LIMIT_GPSLOCK', '''Pre-initialization.''')
LIMIT_GEOFENCE = 2 # Disabled.
enums['LIMIT_MODULE'][2] = EnumEntry('LIMIT_GEOFENCE', '''Disabled.''')
LIMIT_ALTITUDE = 4 # Checking limits.
enums['LIMIT_MODULE'][4] = EnumEntry('LIMIT_ALTITUDE', '''Checking limits.''')
LIMIT_MODULE_ENUM_END = 5 # 
enums['LIMIT_MODULE'][5] = EnumEntry('LIMIT_MODULE_ENUM_END', '''''')

# RALLY_FLAGS
enums['RALLY_FLAGS'] = {}
FAVORABLE_WIND = 1 # Flag set when requiring favorable winds for landing.
enums['RALLY_FLAGS'][1] = EnumEntry('FAVORABLE_WIND', '''Flag set when requiring favorable winds for landing.''')
LAND_IMMEDIATELY = 2 # Flag set when plane is to immediately descend to break altitude and
                        # land without GCS intervention. Flag not set
                        # when plane is to loiter at Rally point until
                        # commanded to land.
enums['RALLY_FLAGS'][2] = EnumEntry('LAND_IMMEDIATELY', '''Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag not set when plane is to loiter at Rally point until commanded to land.''')
RALLY_FLAGS_ENUM_END = 3 # 
enums['RALLY_FLAGS'][3] = EnumEntry('RALLY_FLAGS_ENUM_END', '''''')

# GRIPPER_ACTIONS
enums['GRIPPER_ACTIONS'] = {}
GRIPPER_ACTION_RELEASE = 0 # Gripper release cargo.
enums['GRIPPER_ACTIONS'][0] = EnumEntry('GRIPPER_ACTION_RELEASE', '''Gripper release cargo.''')
GRIPPER_ACTION_GRAB = 1 # Gripper grab onto cargo.
enums['GRIPPER_ACTIONS'][1] = EnumEntry('GRIPPER_ACTION_GRAB', '''Gripper grab onto cargo.''')
GRIPPER_ACTIONS_ENUM_END = 2 # 
enums['GRIPPER_ACTIONS'][2] = EnumEntry('GRIPPER_ACTIONS_ENUM_END', '''''')

# WINCH_ACTIONS
enums['WINCH_ACTIONS'] = {}
WINCH_RELAXED = 0 # Relax winch.
enums['WINCH_ACTIONS'][0] = EnumEntry('WINCH_RELAXED', '''Relax winch.''')
WINCH_RELATIVE_LENGTH_CONTROL = 1 # Winch unwinds or winds specified length of cable optionally using
                        # specified rate.
enums['WINCH_ACTIONS'][1] = EnumEntry('WINCH_RELATIVE_LENGTH_CONTROL', '''Winch unwinds or winds specified length of cable optionally using specified rate.''')
WINCH_RATE_CONTROL = 2 # Winch unwinds or winds cable at specified rate in meters/seconds.
enums['WINCH_ACTIONS'][2] = EnumEntry('WINCH_RATE_CONTROL', '''Winch unwinds or winds cable at specified rate in meters/seconds.''')
WINCH_ACTIONS_ENUM_END = 3 # 
enums['WINCH_ACTIONS'][3] = EnumEntry('WINCH_ACTIONS_ENUM_END', '''''')

# CAMERA_STATUS_TYPES
enums['CAMERA_STATUS_TYPES'] = {}
CAMERA_STATUS_TYPE_HEARTBEAT = 0 # Camera heartbeat, announce camera component ID at 1Hz.
enums['CAMERA_STATUS_TYPES'][0] = EnumEntry('CAMERA_STATUS_TYPE_HEARTBEAT', '''Camera heartbeat, announce camera component ID at 1Hz.''')
CAMERA_STATUS_TYPE_TRIGGER = 1 # Camera image triggered.
enums['CAMERA_STATUS_TYPES'][1] = EnumEntry('CAMERA_STATUS_TYPE_TRIGGER', '''Camera image triggered.''')
CAMERA_STATUS_TYPE_DISCONNECT = 2 # Camera connection lost.
enums['CAMERA_STATUS_TYPES'][2] = EnumEntry('CAMERA_STATUS_TYPE_DISCONNECT', '''Camera connection lost.''')
CAMERA_STATUS_TYPE_ERROR = 3 # Camera unknown error.
enums['CAMERA_STATUS_TYPES'][3] = EnumEntry('CAMERA_STATUS_TYPE_ERROR', '''Camera unknown error.''')
CAMERA_STATUS_TYPE_LOWBATT = 4 # Camera battery low. Parameter p1 shows reported voltage.
enums['CAMERA_STATUS_TYPES'][4] = EnumEntry('CAMERA_STATUS_TYPE_LOWBATT', '''Camera battery low. Parameter p1 shows reported voltage.''')
CAMERA_STATUS_TYPE_LOWSTORE = 5 # Camera storage low. Parameter p1 shows reported shots remaining.
enums['CAMERA_STATUS_TYPES'][5] = EnumEntry('CAMERA_STATUS_TYPE_LOWSTORE', '''Camera storage low. Parameter p1 shows reported shots remaining.''')
CAMERA_STATUS_TYPE_LOWSTOREV = 6 # Camera storage low. Parameter p1 shows reported video minutes
                        # remaining.
enums['CAMERA_STATUS_TYPES'][6] = EnumEntry('CAMERA_STATUS_TYPE_LOWSTOREV', '''Camera storage low. Parameter p1 shows reported video minutes remaining.''')
CAMERA_STATUS_TYPES_ENUM_END = 7 # 
enums['CAMERA_STATUS_TYPES'][7] = EnumEntry('CAMERA_STATUS_TYPES_ENUM_END', '''''')

# CAMERA_FEEDBACK_FLAGS
enums['CAMERA_FEEDBACK_FLAGS'] = {}
CAMERA_FEEDBACK_PHOTO = 0 # Shooting photos, not video.
enums['CAMERA_FEEDBACK_FLAGS'][0] = EnumEntry('CAMERA_FEEDBACK_PHOTO', '''Shooting photos, not video.''')
CAMERA_FEEDBACK_VIDEO = 1 # Shooting video, not stills.
enums['CAMERA_FEEDBACK_FLAGS'][1] = EnumEntry('CAMERA_FEEDBACK_VIDEO', '''Shooting video, not stills.''')
CAMERA_FEEDBACK_BADEXPOSURE = 2 # Unable to achieve requested exposure (e.g. shutter speed too low).
enums['CAMERA_FEEDBACK_FLAGS'][2] = EnumEntry('CAMERA_FEEDBACK_BADEXPOSURE', '''Unable to achieve requested exposure (e.g. shutter speed too low).''')
CAMERA_FEEDBACK_CLOSEDLOOP = 3 # Closed loop feedback from camera, we know for sure it has successfully
                        # taken a picture.
enums['CAMERA_FEEDBACK_FLAGS'][3] = EnumEntry('CAMERA_FEEDBACK_CLOSEDLOOP', '''Closed loop feedback from camera, we know for sure it has successfully taken a picture.''')
CAMERA_FEEDBACK_OPENLOOP = 4 # Open loop camera, an image trigger has been requested but we can't
                        # know for sure it has successfully taken a
                        # picture.
enums['CAMERA_FEEDBACK_FLAGS'][4] = EnumEntry('CAMERA_FEEDBACK_OPENLOOP', '''Open loop camera, an image trigger has been requested but we can't know for sure it has successfully taken a picture.''')
CAMERA_FEEDBACK_FLAGS_ENUM_END = 5 # 
enums['CAMERA_FEEDBACK_FLAGS'][5] = EnumEntry('CAMERA_FEEDBACK_FLAGS_ENUM_END', '''''')

# MAV_MODE_GIMBAL
enums['MAV_MODE_GIMBAL'] = {}
MAV_MODE_GIMBAL_UNINITIALIZED = 0 # Gimbal is powered on but has not started initializing yet.
enums['MAV_MODE_GIMBAL'][0] = EnumEntry('MAV_MODE_GIMBAL_UNINITIALIZED', '''Gimbal is powered on but has not started initializing yet.''')
MAV_MODE_GIMBAL_CALIBRATING_PITCH = 1 # Gimbal is currently running calibration on the pitch axis.
enums['MAV_MODE_GIMBAL'][1] = EnumEntry('MAV_MODE_GIMBAL_CALIBRATING_PITCH', '''Gimbal is currently running calibration on the pitch axis.''')
MAV_MODE_GIMBAL_CALIBRATING_ROLL = 2 # Gimbal is currently running calibration on the roll axis.
enums['MAV_MODE_GIMBAL'][2] = EnumEntry('MAV_MODE_GIMBAL_CALIBRATING_ROLL', '''Gimbal is currently running calibration on the roll axis.''')
MAV_MODE_GIMBAL_CALIBRATING_YAW = 3 # Gimbal is currently running calibration on the yaw axis.
enums['MAV_MODE_GIMBAL'][3] = EnumEntry('MAV_MODE_GIMBAL_CALIBRATING_YAW', '''Gimbal is currently running calibration on the yaw axis.''')
MAV_MODE_GIMBAL_INITIALIZED = 4 # Gimbal has finished calibrating and initializing, but is relaxed
                        # pending reception of first rate command from
                        # copter.
enums['MAV_MODE_GIMBAL'][4] = EnumEntry('MAV_MODE_GIMBAL_INITIALIZED', '''Gimbal has finished calibrating and initializing, but is relaxed pending reception of first rate command from copter.''')
MAV_MODE_GIMBAL_ACTIVE = 5 # Gimbal is actively stabilizing.
enums['MAV_MODE_GIMBAL'][5] = EnumEntry('MAV_MODE_GIMBAL_ACTIVE', '''Gimbal is actively stabilizing.''')
MAV_MODE_GIMBAL_RATE_CMD_TIMEOUT = 6 # Gimbal is relaxed because it missed more than 10 expected rate command
                        # messages in a row. Gimbal will move back to
                        # active mode when it receives a new rate
                        # command.
enums['MAV_MODE_GIMBAL'][6] = EnumEntry('MAV_MODE_GIMBAL_RATE_CMD_TIMEOUT', '''Gimbal is relaxed because it missed more than 10 expected rate command messages in a row. Gimbal will move back to active mode when it receives a new rate command.''')
MAV_MODE_GIMBAL_ENUM_END = 7 # 
enums['MAV_MODE_GIMBAL'][7] = EnumEntry('MAV_MODE_GIMBAL_ENUM_END', '''''')

# GIMBAL_AXIS
enums['GIMBAL_AXIS'] = {}
GIMBAL_AXIS_YAW = 0 # Gimbal yaw axis.
enums['GIMBAL_AXIS'][0] = EnumEntry('GIMBAL_AXIS_YAW', '''Gimbal yaw axis.''')
GIMBAL_AXIS_PITCH = 1 # Gimbal pitch axis.
enums['GIMBAL_AXIS'][1] = EnumEntry('GIMBAL_AXIS_PITCH', '''Gimbal pitch axis.''')
GIMBAL_AXIS_ROLL = 2 # Gimbal roll axis.
enums['GIMBAL_AXIS'][2] = EnumEntry('GIMBAL_AXIS_ROLL', '''Gimbal roll axis.''')
GIMBAL_AXIS_ENUM_END = 3 # 
enums['GIMBAL_AXIS'][3] = EnumEntry('GIMBAL_AXIS_ENUM_END', '''''')

# GIMBAL_AXIS_CALIBRATION_STATUS
enums['GIMBAL_AXIS_CALIBRATION_STATUS'] = {}
GIMBAL_AXIS_CALIBRATION_STATUS_IN_PROGRESS = 0 # Axis calibration is in progress.
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][0] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_IN_PROGRESS', '''Axis calibration is in progress.''')
GIMBAL_AXIS_CALIBRATION_STATUS_SUCCEEDED = 1 # Axis calibration succeeded.
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][1] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_SUCCEEDED', '''Axis calibration succeeded.''')
GIMBAL_AXIS_CALIBRATION_STATUS_FAILED = 2 # Axis calibration failed.
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][2] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_FAILED', '''Axis calibration failed.''')
GIMBAL_AXIS_CALIBRATION_STATUS_ENUM_END = 3 # 
enums['GIMBAL_AXIS_CALIBRATION_STATUS'][3] = EnumEntry('GIMBAL_AXIS_CALIBRATION_STATUS_ENUM_END', '''''')

# GIMBAL_AXIS_CALIBRATION_REQUIRED
enums['GIMBAL_AXIS_CALIBRATION_REQUIRED'] = {}
GIMBAL_AXIS_CALIBRATION_REQUIRED_UNKNOWN = 0 # Whether or not this axis requires calibration is unknown at this time.
enums['GIMBAL_AXIS_CALIBRATION_REQUIRED'][0] = EnumEntry('GIMBAL_AXIS_CALIBRATION_REQUIRED_UNKNOWN', '''Whether or not this axis requires calibration is unknown at this time.''')
GIMBAL_AXIS_CALIBRATION_REQUIRED_TRUE = 1 # This axis requires calibration.
enums['GIMBAL_AXIS_CALIBRATION_REQUIRED'][1] = EnumEntry('GIMBAL_AXIS_CALIBRATION_REQUIRED_TRUE', '''This axis requires calibration.''')
GIMBAL_AXIS_CALIBRATION_REQUIRED_FALSE = 2 # This axis does not require calibration.
enums['GIMBAL_AXIS_CALIBRATION_REQUIRED'][2] = EnumEntry('GIMBAL_AXIS_CALIBRATION_REQUIRED_FALSE', '''This axis does not require calibration.''')
GIMBAL_AXIS_CALIBRATION_REQUIRED_ENUM_END = 3 # 
enums['GIMBAL_AXIS_CALIBRATION_REQUIRED'][3] = EnumEntry('GIMBAL_AXIS_CALIBRATION_REQUIRED_ENUM_END', '''''')

# GOPRO_HEARTBEAT_STATUS
enums['GOPRO_HEARTBEAT_STATUS'] = {}
GOPRO_HEARTBEAT_STATUS_DISCONNECTED = 0 # No GoPro connected.
enums['GOPRO_HEARTBEAT_STATUS'][0] = EnumEntry('GOPRO_HEARTBEAT_STATUS_DISCONNECTED', '''No GoPro connected.''')
GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE = 1 # The detected GoPro is not HeroBus compatible.
enums['GOPRO_HEARTBEAT_STATUS'][1] = EnumEntry('GOPRO_HEARTBEAT_STATUS_INCOMPATIBLE', '''The detected GoPro is not HeroBus compatible.''')
GOPRO_HEARTBEAT_STATUS_CONNECTED = 2 # A HeroBus compatible GoPro is connected.
enums['GOPRO_HEARTBEAT_STATUS'][2] = EnumEntry('GOPRO_HEARTBEAT_STATUS_CONNECTED', '''A HeroBus compatible GoPro is connected.''')
GOPRO_HEARTBEAT_STATUS_ERROR = 3 # An unrecoverable error was encountered with the connected GoPro, it
                        # may require a power cycle.
enums['GOPRO_HEARTBEAT_STATUS'][3] = EnumEntry('GOPRO_HEARTBEAT_STATUS_ERROR', '''An unrecoverable error was encountered with the connected GoPro, it may require a power cycle.''')
GOPRO_HEARTBEAT_STATUS_ENUM_END = 4 # 
enums['GOPRO_HEARTBEAT_STATUS'][4] = EnumEntry('GOPRO_HEARTBEAT_STATUS_ENUM_END', '''''')

# GOPRO_HEARTBEAT_FLAGS
enums['GOPRO_HEARTBEAT_FLAGS'] = {}
GOPRO_FLAG_RECORDING = 1 # GoPro is currently recording.
enums['GOPRO_HEARTBEAT_FLAGS'][1] = EnumEntry('GOPRO_FLAG_RECORDING', '''GoPro is currently recording.''')
GOPRO_HEARTBEAT_FLAGS_ENUM_END = 2 # 
enums['GOPRO_HEARTBEAT_FLAGS'][2] = EnumEntry('GOPRO_HEARTBEAT_FLAGS_ENUM_END', '''''')

# GOPRO_REQUEST_STATUS
enums['GOPRO_REQUEST_STATUS'] = {}
GOPRO_REQUEST_SUCCESS = 0 # The write message with ID indicated succeeded.
enums['GOPRO_REQUEST_STATUS'][0] = EnumEntry('GOPRO_REQUEST_SUCCESS', '''The write message with ID indicated succeeded.''')
GOPRO_REQUEST_FAILED = 1 # The write message with ID indicated failed.
enums['GOPRO_REQUEST_STATUS'][1] = EnumEntry('GOPRO_REQUEST_FAILED', '''The write message with ID indicated failed.''')
GOPRO_REQUEST_STATUS_ENUM_END = 2 # 
enums['GOPRO_REQUEST_STATUS'][2] = EnumEntry('GOPRO_REQUEST_STATUS_ENUM_END', '''''')

# GOPRO_COMMAND
enums['GOPRO_COMMAND'] = {}
GOPRO_COMMAND_POWER = 0 # (Get/Set).
enums['GOPRO_COMMAND'][0] = EnumEntry('GOPRO_COMMAND_POWER', '''(Get/Set).''')
GOPRO_COMMAND_CAPTURE_MODE = 1 # (Get/Set).
enums['GOPRO_COMMAND'][1] = EnumEntry('GOPRO_COMMAND_CAPTURE_MODE', '''(Get/Set).''')
GOPRO_COMMAND_SHUTTER = 2 # (___/Set).
enums['GOPRO_COMMAND'][2] = EnumEntry('GOPRO_COMMAND_SHUTTER', '''(___/Set).''')
GOPRO_COMMAND_BATTERY = 3 # (Get/___).
enums['GOPRO_COMMAND'][3] = EnumEntry('GOPRO_COMMAND_BATTERY', '''(Get/___).''')
GOPRO_COMMAND_MODEL = 4 # (Get/___).
enums['GOPRO_COMMAND'][4] = EnumEntry('GOPRO_COMMAND_MODEL', '''(Get/___).''')
GOPRO_COMMAND_VIDEO_SETTINGS = 5 # (Get/Set).
enums['GOPRO_COMMAND'][5] = EnumEntry('GOPRO_COMMAND_VIDEO_SETTINGS', '''(Get/Set).''')
GOPRO_COMMAND_LOW_LIGHT = 6 # (Get/Set).
enums['GOPRO_COMMAND'][6] = EnumEntry('GOPRO_COMMAND_LOW_LIGHT', '''(Get/Set).''')
GOPRO_COMMAND_PHOTO_RESOLUTION = 7 # (Get/Set).
enums['GOPRO_COMMAND'][7] = EnumEntry('GOPRO_COMMAND_PHOTO_RESOLUTION', '''(Get/Set).''')
GOPRO_COMMAND_PHOTO_BURST_RATE = 8 # (Get/Set).
enums['GOPRO_COMMAND'][8] = EnumEntry('GOPRO_COMMAND_PHOTO_BURST_RATE', '''(Get/Set).''')
GOPRO_COMMAND_PROTUNE = 9 # (Get/Set).
enums['GOPRO_COMMAND'][9] = EnumEntry('GOPRO_COMMAND_PROTUNE', '''(Get/Set).''')
GOPRO_COMMAND_PROTUNE_WHITE_BALANCE = 10 # (Get/Set) Hero 3+ Only.
enums['GOPRO_COMMAND'][10] = EnumEntry('GOPRO_COMMAND_PROTUNE_WHITE_BALANCE', '''(Get/Set) Hero 3+ Only.''')
GOPRO_COMMAND_PROTUNE_COLOUR = 11 # (Get/Set) Hero 3+ Only.
enums['GOPRO_COMMAND'][11] = EnumEntry('GOPRO_COMMAND_PROTUNE_COLOUR', '''(Get/Set) Hero 3+ Only.''')
GOPRO_COMMAND_PROTUNE_GAIN = 12 # (Get/Set) Hero 3+ Only.
enums['GOPRO_COMMAND'][12] = EnumEntry('GOPRO_COMMAND_PROTUNE_GAIN', '''(Get/Set) Hero 3+ Only.''')
GOPRO_COMMAND_PROTUNE_SHARPNESS = 13 # (Get/Set) Hero 3+ Only.
enums['GOPRO_COMMAND'][13] = EnumEntry('GOPRO_COMMAND_PROTUNE_SHARPNESS', '''(Get/Set) Hero 3+ Only.''')
GOPRO_COMMAND_PROTUNE_EXPOSURE = 14 # (Get/Set) Hero 3+ Only.
enums['GOPRO_COMMAND'][14] = EnumEntry('GOPRO_COMMAND_PROTUNE_EXPOSURE', '''(Get/Set) Hero 3+ Only.''')
GOPRO_COMMAND_TIME = 15 # (Get/Set).
enums['GOPRO_COMMAND'][15] = EnumEntry('GOPRO_COMMAND_TIME', '''(Get/Set).''')
GOPRO_COMMAND_CHARGING = 16 # (Get/Set).
enums['GOPRO_COMMAND'][16] = EnumEntry('GOPRO_COMMAND_CHARGING', '''(Get/Set).''')
GOPRO_COMMAND_ENUM_END = 17 # 
enums['GOPRO_COMMAND'][17] = EnumEntry('GOPRO_COMMAND_ENUM_END', '''''')

# GOPRO_CAPTURE_MODE
enums['GOPRO_CAPTURE_MODE'] = {}
GOPRO_CAPTURE_MODE_VIDEO = 0 # Video mode.
enums['GOPRO_CAPTURE_MODE'][0] = EnumEntry('GOPRO_CAPTURE_MODE_VIDEO', '''Video mode.''')
GOPRO_CAPTURE_MODE_PHOTO = 1 # Photo mode.
enums['GOPRO_CAPTURE_MODE'][1] = EnumEntry('GOPRO_CAPTURE_MODE_PHOTO', '''Photo mode.''')
GOPRO_CAPTURE_MODE_BURST = 2 # Burst mode, Hero 3+ only.
enums['GOPRO_CAPTURE_MODE'][2] = EnumEntry('GOPRO_CAPTURE_MODE_BURST', '''Burst mode, Hero 3+ only.''')
GOPRO_CAPTURE_MODE_TIME_LAPSE = 3 # Time lapse mode, Hero 3+ only.
enums['GOPRO_CAPTURE_MODE'][3] = EnumEntry('GOPRO_CAPTURE_MODE_TIME_LAPSE', '''Time lapse mode, Hero 3+ only.''')
GOPRO_CAPTURE_MODE_MULTI_SHOT = 4 # Multi shot mode, Hero 4 only.
enums['GOPRO_CAPTURE_MODE'][4] = EnumEntry('GOPRO_CAPTURE_MODE_MULTI_SHOT', '''Multi shot mode, Hero 4 only.''')
GOPRO_CAPTURE_MODE_PLAYBACK = 5 # Playback mode, Hero 4 only, silver only except when LCD or HDMI is
                        # connected to black.
enums['GOPRO_CAPTURE_MODE'][5] = EnumEntry('GOPRO_CAPTURE_MODE_PLAYBACK', '''Playback mode, Hero 4 only, silver only except when LCD or HDMI is connected to black.''')
GOPRO_CAPTURE_MODE_SETUP = 6 # Playback mode, Hero 4 only.
enums['GOPRO_CAPTURE_MODE'][6] = EnumEntry('GOPRO_CAPTURE_MODE_SETUP', '''Playback mode, Hero 4 only.''')
GOPRO_CAPTURE_MODE_UNKNOWN = 255 # Mode not yet known.
enums['GOPRO_CAPTURE_MODE'][255] = EnumEntry('GOPRO_CAPTURE_MODE_UNKNOWN', '''Mode not yet known.''')
GOPRO_CAPTURE_MODE_ENUM_END = 256 # 
enums['GOPRO_CAPTURE_MODE'][256] = EnumEntry('GOPRO_CAPTURE_MODE_ENUM_END', '''''')

# GOPRO_RESOLUTION
enums['GOPRO_RESOLUTION'] = {}
GOPRO_RESOLUTION_480p = 0 # 848 x 480 (480p).
enums['GOPRO_RESOLUTION'][0] = EnumEntry('GOPRO_RESOLUTION_480p', '''848 x 480 (480p).''')
GOPRO_RESOLUTION_720p = 1 # 1280 x 720 (720p).
enums['GOPRO_RESOLUTION'][1] = EnumEntry('GOPRO_RESOLUTION_720p', '''1280 x 720 (720p).''')
GOPRO_RESOLUTION_960p = 2 # 1280 x 960 (960p).
enums['GOPRO_RESOLUTION'][2] = EnumEntry('GOPRO_RESOLUTION_960p', '''1280 x 960 (960p).''')
GOPRO_RESOLUTION_1080p = 3 # 1920 x 1080 (1080p).
enums['GOPRO_RESOLUTION'][3] = EnumEntry('GOPRO_RESOLUTION_1080p', '''1920 x 1080 (1080p).''')
GOPRO_RESOLUTION_1440p = 4 # 1920 x 1440 (1440p).
enums['GOPRO_RESOLUTION'][4] = EnumEntry('GOPRO_RESOLUTION_1440p', '''1920 x 1440 (1440p).''')
GOPRO_RESOLUTION_2_7k_17_9 = 5 # 2704 x 1440 (2.7k-17:9).
enums['GOPRO_RESOLUTION'][5] = EnumEntry('GOPRO_RESOLUTION_2_7k_17_9', '''2704 x 1440 (2.7k-17:9).''')
GOPRO_RESOLUTION_2_7k_16_9 = 6 # 2704 x 1524 (2.7k-16:9).
enums['GOPRO_RESOLUTION'][6] = EnumEntry('GOPRO_RESOLUTION_2_7k_16_9', '''2704 x 1524 (2.7k-16:9).''')
GOPRO_RESOLUTION_2_7k_4_3 = 7 # 2704 x 2028 (2.7k-4:3).
enums['GOPRO_RESOLUTION'][7] = EnumEntry('GOPRO_RESOLUTION_2_7k_4_3', '''2704 x 2028 (2.7k-4:3).''')
GOPRO_RESOLUTION_4k_16_9 = 8 # 3840 x 2160 (4k-16:9).
enums['GOPRO_RESOLUTION'][8] = EnumEntry('GOPRO_RESOLUTION_4k_16_9', '''3840 x 2160 (4k-16:9).''')
GOPRO_RESOLUTION_4k_17_9 = 9 # 4096 x 2160 (4k-17:9).
enums['GOPRO_RESOLUTION'][9] = EnumEntry('GOPRO_RESOLUTION_4k_17_9', '''4096 x 2160 (4k-17:9).''')
GOPRO_RESOLUTION_720p_SUPERVIEW = 10 # 1280 x 720 (720p-SuperView).
enums['GOPRO_RESOLUTION'][10] = EnumEntry('GOPRO_RESOLUTION_720p_SUPERVIEW', '''1280 x 720 (720p-SuperView).''')
GOPRO_RESOLUTION_1080p_SUPERVIEW = 11 # 1920 x 1080 (1080p-SuperView).
enums['GOPRO_RESOLUTION'][11] = EnumEntry('GOPRO_RESOLUTION_1080p_SUPERVIEW', '''1920 x 1080 (1080p-SuperView).''')
GOPRO_RESOLUTION_2_7k_SUPERVIEW = 12 # 2704 x 1520 (2.7k-SuperView).
enums['GOPRO_RESOLUTION'][12] = EnumEntry('GOPRO_RESOLUTION_2_7k_SUPERVIEW', '''2704 x 1520 (2.7k-SuperView).''')
GOPRO_RESOLUTION_4k_SUPERVIEW = 13 # 3840 x 2160 (4k-SuperView).
enums['GOPRO_RESOLUTION'][13] = EnumEntry('GOPRO_RESOLUTION_4k_SUPERVIEW', '''3840 x 2160 (4k-SuperView).''')
GOPRO_RESOLUTION_ENUM_END = 14 # 
enums['GOPRO_RESOLUTION'][14] = EnumEntry('GOPRO_RESOLUTION_ENUM_END', '''''')

# GOPRO_FRAME_RATE
enums['GOPRO_FRAME_RATE'] = {}
GOPRO_FRAME_RATE_12 = 0 # 12 FPS.
enums['GOPRO_FRAME_RATE'][0] = EnumEntry('GOPRO_FRAME_RATE_12', '''12 FPS.''')
GOPRO_FRAME_RATE_15 = 1 # 15 FPS.
enums['GOPRO_FRAME_RATE'][1] = EnumEntry('GOPRO_FRAME_RATE_15', '''15 FPS.''')
GOPRO_FRAME_RATE_24 = 2 # 24 FPS.
enums['GOPRO_FRAME_RATE'][2] = EnumEntry('GOPRO_FRAME_RATE_24', '''24 FPS.''')
GOPRO_FRAME_RATE_25 = 3 # 25 FPS.
enums['GOPRO_FRAME_RATE'][3] = EnumEntry('GOPRO_FRAME_RATE_25', '''25 FPS.''')
GOPRO_FRAME_RATE_30 = 4 # 30 FPS.
enums['GOPRO_FRAME_RATE'][4] = EnumEntry('GOPRO_FRAME_RATE_30', '''30 FPS.''')
GOPRO_FRAME_RATE_48 = 5 # 48 FPS.
enums['GOPRO_FRAME_RATE'][5] = EnumEntry('GOPRO_FRAME_RATE_48', '''48 FPS.''')
GOPRO_FRAME_RATE_50 = 6 # 50 FPS.
enums['GOPRO_FRAME_RATE'][6] = EnumEntry('GOPRO_FRAME_RATE_50', '''50 FPS.''')
GOPRO_FRAME_RATE_60 = 7 # 60 FPS.
enums['GOPRO_FRAME_RATE'][7] = EnumEntry('GOPRO_FRAME_RATE_60', '''60 FPS.''')
GOPRO_FRAME_RATE_80 = 8 # 80 FPS.
enums['GOPRO_FRAME_RATE'][8] = EnumEntry('GOPRO_FRAME_RATE_80', '''80 FPS.''')
GOPRO_FRAME_RATE_90 = 9 # 90 FPS.
enums['GOPRO_FRAME_RATE'][9] = EnumEntry('GOPRO_FRAME_RATE_90', '''90 FPS.''')
GOPRO_FRAME_RATE_100 = 10 # 100 FPS.
enums['GOPRO_FRAME_RATE'][10] = EnumEntry('GOPRO_FRAME_RATE_100', '''100 FPS.''')
GOPRO_FRAME_RATE_120 = 11 # 120 FPS.
enums['GOPRO_FRAME_RATE'][11] = EnumEntry('GOPRO_FRAME_RATE_120', '''120 FPS.''')
GOPRO_FRAME_RATE_240 = 12 # 240 FPS.
enums['GOPRO_FRAME_RATE'][12] = EnumEntry('GOPRO_FRAME_RATE_240', '''240 FPS.''')
GOPRO_FRAME_RATE_12_5 = 13 # 12.5 FPS.
enums['GOPRO_FRAME_RATE'][13] = EnumEntry('GOPRO_FRAME_RATE_12_5', '''12.5 FPS.''')
GOPRO_FRAME_RATE_ENUM_END = 14 # 
enums['GOPRO_FRAME_RATE'][14] = EnumEntry('GOPRO_FRAME_RATE_ENUM_END', '''''')

# GOPRO_FIELD_OF_VIEW
enums['GOPRO_FIELD_OF_VIEW'] = {}
GOPRO_FIELD_OF_VIEW_WIDE = 0 # 0x00: Wide.
enums['GOPRO_FIELD_OF_VIEW'][0] = EnumEntry('GOPRO_FIELD_OF_VIEW_WIDE', '''0x00: Wide.''')
GOPRO_FIELD_OF_VIEW_MEDIUM = 1 # 0x01: Medium.
enums['GOPRO_FIELD_OF_VIEW'][1] = EnumEntry('GOPRO_FIELD_OF_VIEW_MEDIUM', '''0x01: Medium.''')
GOPRO_FIELD_OF_VIEW_NARROW = 2 # 0x02: Narrow.
enums['GOPRO_FIELD_OF_VIEW'][2] = EnumEntry('GOPRO_FIELD_OF_VIEW_NARROW', '''0x02: Narrow.''')
GOPRO_FIELD_OF_VIEW_ENUM_END = 3 # 
enums['GOPRO_FIELD_OF_VIEW'][3] = EnumEntry('GOPRO_FIELD_OF_VIEW_ENUM_END', '''''')

# GOPRO_VIDEO_SETTINGS_FLAGS
enums['GOPRO_VIDEO_SETTINGS_FLAGS'] = {}
GOPRO_VIDEO_SETTINGS_TV_MODE = 1 # 0=NTSC, 1=PAL.
enums['GOPRO_VIDEO_SETTINGS_FLAGS'][1] = EnumEntry('GOPRO_VIDEO_SETTINGS_TV_MODE', '''0=NTSC, 1=PAL.''')
GOPRO_VIDEO_SETTINGS_FLAGS_ENUM_END = 2 # 
enums['GOPRO_VIDEO_SETTINGS_FLAGS'][2] = EnumEntry('GOPRO_VIDEO_SETTINGS_FLAGS_ENUM_END', '''''')

# GOPRO_PHOTO_RESOLUTION
enums['GOPRO_PHOTO_RESOLUTION'] = {}
GOPRO_PHOTO_RESOLUTION_5MP_MEDIUM = 0 # 5MP Medium.
enums['GOPRO_PHOTO_RESOLUTION'][0] = EnumEntry('GOPRO_PHOTO_RESOLUTION_5MP_MEDIUM', '''5MP Medium.''')
GOPRO_PHOTO_RESOLUTION_7MP_MEDIUM = 1 # 7MP Medium.
enums['GOPRO_PHOTO_RESOLUTION'][1] = EnumEntry('GOPRO_PHOTO_RESOLUTION_7MP_MEDIUM', '''7MP Medium.''')
GOPRO_PHOTO_RESOLUTION_7MP_WIDE = 2 # 7MP Wide.
enums['GOPRO_PHOTO_RESOLUTION'][2] = EnumEntry('GOPRO_PHOTO_RESOLUTION_7MP_WIDE', '''7MP Wide.''')
GOPRO_PHOTO_RESOLUTION_10MP_WIDE = 3 # 10MP Wide.
enums['GOPRO_PHOTO_RESOLUTION'][3] = EnumEntry('GOPRO_PHOTO_RESOLUTION_10MP_WIDE', '''10MP Wide.''')
GOPRO_PHOTO_RESOLUTION_12MP_WIDE = 4 # 12MP Wide.
enums['GOPRO_PHOTO_RESOLUTION'][4] = EnumEntry('GOPRO_PHOTO_RESOLUTION_12MP_WIDE', '''12MP Wide.''')
GOPRO_PHOTO_RESOLUTION_ENUM_END = 5 # 
enums['GOPRO_PHOTO_RESOLUTION'][5] = EnumEntry('GOPRO_PHOTO_RESOLUTION_ENUM_END', '''''')

# GOPRO_PROTUNE_WHITE_BALANCE
enums['GOPRO_PROTUNE_WHITE_BALANCE'] = {}
GOPRO_PROTUNE_WHITE_BALANCE_AUTO = 0 # Auto.
enums['GOPRO_PROTUNE_WHITE_BALANCE'][0] = EnumEntry('GOPRO_PROTUNE_WHITE_BALANCE_AUTO', '''Auto.''')
GOPRO_PROTUNE_WHITE_BALANCE_3000K = 1 # 3000K.
enums['GOPRO_PROTUNE_WHITE_BALANCE'][1] = EnumEntry('GOPRO_PROTUNE_WHITE_BALANCE_3000K', '''3000K.''')
GOPRO_PROTUNE_WHITE_BALANCE_5500K = 2 # 5500K.
enums['GOPRO_PROTUNE_WHITE_BALANCE'][2] = EnumEntry('GOPRO_PROTUNE_WHITE_BALANCE_5500K', '''5500K.''')
GOPRO_PROTUNE_WHITE_BALANCE_6500K = 3 # 6500K.
enums['GOPRO_PROTUNE_WHITE_BALANCE'][3] = EnumEntry('GOPRO_PROTUNE_WHITE_BALANCE_6500K', '''6500K.''')
GOPRO_PROTUNE_WHITE_BALANCE_RAW = 4 # Camera Raw.
enums['GOPRO_PROTUNE_WHITE_BALANCE'][4] = EnumEntry('GOPRO_PROTUNE_WHITE_BALANCE_RAW', '''Camera Raw.''')
GOPRO_PROTUNE_WHITE_BALANCE_ENUM_END = 5 # 
enums['GOPRO_PROTUNE_WHITE_BALANCE'][5] = EnumEntry('GOPRO_PROTUNE_WHITE_BALANCE_ENUM_END', '''''')

# GOPRO_PROTUNE_COLOUR
enums['GOPRO_PROTUNE_COLOUR'] = {}
GOPRO_PROTUNE_COLOUR_STANDARD = 0 # Auto.
enums['GOPRO_PROTUNE_COLOUR'][0] = EnumEntry('GOPRO_PROTUNE_COLOUR_STANDARD', '''Auto.''')
GOPRO_PROTUNE_COLOUR_NEUTRAL = 1 # Neutral.
enums['GOPRO_PROTUNE_COLOUR'][1] = EnumEntry('GOPRO_PROTUNE_COLOUR_NEUTRAL', '''Neutral.''')
GOPRO_PROTUNE_COLOUR_ENUM_END = 2 # 
enums['GOPRO_PROTUNE_COLOUR'][2] = EnumEntry('GOPRO_PROTUNE_COLOUR_ENUM_END', '''''')

# GOPRO_PROTUNE_GAIN
enums['GOPRO_PROTUNE_GAIN'] = {}
GOPRO_PROTUNE_GAIN_400 = 0 # ISO 400.
enums['GOPRO_PROTUNE_GAIN'][0] = EnumEntry('GOPRO_PROTUNE_GAIN_400', '''ISO 400.''')
GOPRO_PROTUNE_GAIN_800 = 1 # ISO 800 (Only Hero 4).
enums['GOPRO_PROTUNE_GAIN'][1] = EnumEntry('GOPRO_PROTUNE_GAIN_800', '''ISO 800 (Only Hero 4).''')
GOPRO_PROTUNE_GAIN_1600 = 2 # ISO 1600.
enums['GOPRO_PROTUNE_GAIN'][2] = EnumEntry('GOPRO_PROTUNE_GAIN_1600', '''ISO 1600.''')
GOPRO_PROTUNE_GAIN_3200 = 3 # ISO 3200 (Only Hero 4).
enums['GOPRO_PROTUNE_GAIN'][3] = EnumEntry('GOPRO_PROTUNE_GAIN_3200', '''ISO 3200 (Only Hero 4).''')
GOPRO_PROTUNE_GAIN_6400 = 4 # ISO 6400.
enums['GOPRO_PROTUNE_GAIN'][4] = EnumEntry('GOPRO_PROTUNE_GAIN_6400', '''ISO 6400.''')
GOPRO_PROTUNE_GAIN_ENUM_END = 5 # 
enums['GOPRO_PROTUNE_GAIN'][5] = EnumEntry('GOPRO_PROTUNE_GAIN_ENUM_END', '''''')

# GOPRO_PROTUNE_SHARPNESS
enums['GOPRO_PROTUNE_SHARPNESS'] = {}
GOPRO_PROTUNE_SHARPNESS_LOW = 0 # Low Sharpness.
enums['GOPRO_PROTUNE_SHARPNESS'][0] = EnumEntry('GOPRO_PROTUNE_SHARPNESS_LOW', '''Low Sharpness.''')
GOPRO_PROTUNE_SHARPNESS_MEDIUM = 1 # Medium Sharpness.
enums['GOPRO_PROTUNE_SHARPNESS'][1] = EnumEntry('GOPRO_PROTUNE_SHARPNESS_MEDIUM', '''Medium Sharpness.''')
GOPRO_PROTUNE_SHARPNESS_HIGH = 2 # High Sharpness.
enums['GOPRO_PROTUNE_SHARPNESS'][2] = EnumEntry('GOPRO_PROTUNE_SHARPNESS_HIGH', '''High Sharpness.''')
GOPRO_PROTUNE_SHARPNESS_ENUM_END = 3 # 
enums['GOPRO_PROTUNE_SHARPNESS'][3] = EnumEntry('GOPRO_PROTUNE_SHARPNESS_ENUM_END', '''''')

# GOPRO_PROTUNE_EXPOSURE
enums['GOPRO_PROTUNE_EXPOSURE'] = {}
GOPRO_PROTUNE_EXPOSURE_NEG_5_0 = 0 # -5.0 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][0] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_5_0', '''-5.0 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_NEG_4_5 = 1 # -4.5 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][1] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_4_5', '''-4.5 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_NEG_4_0 = 2 # -4.0 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][2] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_4_0', '''-4.0 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_NEG_3_5 = 3 # -3.5 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][3] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_3_5', '''-3.5 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_NEG_3_0 = 4 # -3.0 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][4] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_3_0', '''-3.0 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_NEG_2_5 = 5 # -2.5 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][5] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_2_5', '''-2.5 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_NEG_2_0 = 6 # -2.0 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][6] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_2_0', '''-2.0 EV.''')
GOPRO_PROTUNE_EXPOSURE_NEG_1_5 = 7 # -1.5 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][7] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_1_5', '''-1.5 EV.''')
GOPRO_PROTUNE_EXPOSURE_NEG_1_0 = 8 # -1.0 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][8] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_1_0', '''-1.0 EV.''')
GOPRO_PROTUNE_EXPOSURE_NEG_0_5 = 9 # -0.5 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][9] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_NEG_0_5', '''-0.5 EV.''')
GOPRO_PROTUNE_EXPOSURE_ZERO = 10 # 0.0 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][10] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_ZERO', '''0.0 EV.''')
GOPRO_PROTUNE_EXPOSURE_POS_0_5 = 11 # +0.5 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][11] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_0_5', '''+0.5 EV.''')
GOPRO_PROTUNE_EXPOSURE_POS_1_0 = 12 # +1.0 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][12] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_1_0', '''+1.0 EV.''')
GOPRO_PROTUNE_EXPOSURE_POS_1_5 = 13 # +1.5 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][13] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_1_5', '''+1.5 EV.''')
GOPRO_PROTUNE_EXPOSURE_POS_2_0 = 14 # +2.0 EV.
enums['GOPRO_PROTUNE_EXPOSURE'][14] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_2_0', '''+2.0 EV.''')
GOPRO_PROTUNE_EXPOSURE_POS_2_5 = 15 # +2.5 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][15] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_2_5', '''+2.5 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_POS_3_0 = 16 # +3.0 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][16] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_3_0', '''+3.0 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_POS_3_5 = 17 # +3.5 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][17] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_3_5', '''+3.5 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_POS_4_0 = 18 # +4.0 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][18] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_4_0', '''+4.0 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_POS_4_5 = 19 # +4.5 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][19] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_4_5', '''+4.5 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_POS_5_0 = 20 # +5.0 EV (Hero 3+ Only).
enums['GOPRO_PROTUNE_EXPOSURE'][20] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_POS_5_0', '''+5.0 EV (Hero 3+ Only).''')
GOPRO_PROTUNE_EXPOSURE_ENUM_END = 21 # 
enums['GOPRO_PROTUNE_EXPOSURE'][21] = EnumEntry('GOPRO_PROTUNE_EXPOSURE_ENUM_END', '''''')

# GOPRO_CHARGING
enums['GOPRO_CHARGING'] = {}
GOPRO_CHARGING_DISABLED = 0 # Charging disabled.
enums['GOPRO_CHARGING'][0] = EnumEntry('GOPRO_CHARGING_DISABLED', '''Charging disabled.''')
GOPRO_CHARGING_ENABLED = 1 # Charging enabled.
enums['GOPRO_CHARGING'][1] = EnumEntry('GOPRO_CHARGING_ENABLED', '''Charging enabled.''')
GOPRO_CHARGING_ENUM_END = 2 # 
enums['GOPRO_CHARGING'][2] = EnumEntry('GOPRO_CHARGING_ENUM_END', '''''')

# GOPRO_MODEL
enums['GOPRO_MODEL'] = {}
GOPRO_MODEL_UNKNOWN = 0 # Unknown gopro model.
enums['GOPRO_MODEL'][0] = EnumEntry('GOPRO_MODEL_UNKNOWN', '''Unknown gopro model.''')
GOPRO_MODEL_HERO_3_PLUS_SILVER = 1 # Hero 3+ Silver (HeroBus not supported by GoPro).
enums['GOPRO_MODEL'][1] = EnumEntry('GOPRO_MODEL_HERO_3_PLUS_SILVER', '''Hero 3+ Silver (HeroBus not supported by GoPro).''')
GOPRO_MODEL_HERO_3_PLUS_BLACK = 2 # Hero 3+ Black.
enums['GOPRO_MODEL'][2] = EnumEntry('GOPRO_MODEL_HERO_3_PLUS_BLACK', '''Hero 3+ Black.''')
GOPRO_MODEL_HERO_4_SILVER = 3 # Hero 4 Silver.
enums['GOPRO_MODEL'][3] = EnumEntry('GOPRO_MODEL_HERO_4_SILVER', '''Hero 4 Silver.''')
GOPRO_MODEL_HERO_4_BLACK = 4 # Hero 4 Black.
enums['GOPRO_MODEL'][4] = EnumEntry('GOPRO_MODEL_HERO_4_BLACK', '''Hero 4 Black.''')
GOPRO_MODEL_ENUM_END = 5 # 
enums['GOPRO_MODEL'][5] = EnumEntry('GOPRO_MODEL_ENUM_END', '''''')

# GOPRO_BURST_RATE
enums['GOPRO_BURST_RATE'] = {}
GOPRO_BURST_RATE_3_IN_1_SECOND = 0 # 3 Shots / 1 Second.
enums['GOPRO_BURST_RATE'][0] = EnumEntry('GOPRO_BURST_RATE_3_IN_1_SECOND', '''3 Shots / 1 Second.''')
GOPRO_BURST_RATE_5_IN_1_SECOND = 1 # 5 Shots / 1 Second.
enums['GOPRO_BURST_RATE'][1] = EnumEntry('GOPRO_BURST_RATE_5_IN_1_SECOND', '''5 Shots / 1 Second.''')
GOPRO_BURST_RATE_10_IN_1_SECOND = 2 # 10 Shots / 1 Second.
enums['GOPRO_BURST_RATE'][2] = EnumEntry('GOPRO_BURST_RATE_10_IN_1_SECOND', '''10 Shots / 1 Second.''')
GOPRO_BURST_RATE_10_IN_2_SECOND = 3 # 10 Shots / 2 Second.
enums['GOPRO_BURST_RATE'][3] = EnumEntry('GOPRO_BURST_RATE_10_IN_2_SECOND', '''10 Shots / 2 Second.''')
GOPRO_BURST_RATE_10_IN_3_SECOND = 4 # 10 Shots / 3 Second (Hero 4 Only).
enums['GOPRO_BURST_RATE'][4] = EnumEntry('GOPRO_BURST_RATE_10_IN_3_SECOND', '''10 Shots / 3 Second (Hero 4 Only).''')
GOPRO_BURST_RATE_30_IN_1_SECOND = 5 # 30 Shots / 1 Second.
enums['GOPRO_BURST_RATE'][5] = EnumEntry('GOPRO_BURST_RATE_30_IN_1_SECOND', '''30 Shots / 1 Second.''')
GOPRO_BURST_RATE_30_IN_2_SECOND = 6 # 30 Shots / 2 Second.
enums['GOPRO_BURST_RATE'][6] = EnumEntry('GOPRO_BURST_RATE_30_IN_2_SECOND', '''30 Shots / 2 Second.''')
GOPRO_BURST_RATE_30_IN_3_SECOND = 7 # 30 Shots / 3 Second.
enums['GOPRO_BURST_RATE'][7] = EnumEntry('GOPRO_BURST_RATE_30_IN_3_SECOND', '''30 Shots / 3 Second.''')
GOPRO_BURST_RATE_30_IN_6_SECOND = 8 # 30 Shots / 6 Second.
enums['GOPRO_BURST_RATE'][8] = EnumEntry('GOPRO_BURST_RATE_30_IN_6_SECOND', '''30 Shots / 6 Second.''')
GOPRO_BURST_RATE_ENUM_END = 9 # 
enums['GOPRO_BURST_RATE'][9] = EnumEntry('GOPRO_BURST_RATE_ENUM_END', '''''')

# LED_CONTROL_PATTERN
enums['LED_CONTROL_PATTERN'] = {}
LED_CONTROL_PATTERN_OFF = 0 # LED patterns off (return control to regular vehicle control).
enums['LED_CONTROL_PATTERN'][0] = EnumEntry('LED_CONTROL_PATTERN_OFF', '''LED patterns off (return control to regular vehicle control).''')
LED_CONTROL_PATTERN_FIRMWAREUPDATE = 1 # LEDs show pattern during firmware update.
enums['LED_CONTROL_PATTERN'][1] = EnumEntry('LED_CONTROL_PATTERN_FIRMWAREUPDATE', '''LEDs show pattern during firmware update.''')
LED_CONTROL_PATTERN_CUSTOM = 255 # Custom Pattern using custom bytes fields.
enums['LED_CONTROL_PATTERN'][255] = EnumEntry('LED_CONTROL_PATTERN_CUSTOM', '''Custom Pattern using custom bytes fields.''')
LED_CONTROL_PATTERN_ENUM_END = 256 # 
enums['LED_CONTROL_PATTERN'][256] = EnumEntry('LED_CONTROL_PATTERN_ENUM_END', '''''')

# EKF_STATUS_FLAGS
enums['EKF_STATUS_FLAGS'] = {}
EKF_ATTITUDE = 1 # Set if EKF's attitude estimate is good.
enums['EKF_STATUS_FLAGS'][1] = EnumEntry('EKF_ATTITUDE', '''Set if EKF's attitude estimate is good.''')
EKF_VELOCITY_HORIZ = 2 # Set if EKF's horizontal velocity estimate is good.
enums['EKF_STATUS_FLAGS'][2] = EnumEntry('EKF_VELOCITY_HORIZ', '''Set if EKF's horizontal velocity estimate is good.''')
EKF_VELOCITY_VERT = 4 # Set if EKF's vertical velocity estimate is good.
enums['EKF_STATUS_FLAGS'][4] = EnumEntry('EKF_VELOCITY_VERT', '''Set if EKF's vertical velocity estimate is good.''')
EKF_POS_HORIZ_REL = 8 # Set if EKF's horizontal position (relative) estimate is good.
enums['EKF_STATUS_FLAGS'][8] = EnumEntry('EKF_POS_HORIZ_REL', '''Set if EKF's horizontal position (relative) estimate is good.''')
EKF_POS_HORIZ_ABS = 16 # Set if EKF's horizontal position (absolute) estimate is good.
enums['EKF_STATUS_FLAGS'][16] = EnumEntry('EKF_POS_HORIZ_ABS', '''Set if EKF's horizontal position (absolute) estimate is good.''')
EKF_POS_VERT_ABS = 32 # Set if EKF's vertical position (absolute) estimate is good.
enums['EKF_STATUS_FLAGS'][32] = EnumEntry('EKF_POS_VERT_ABS', '''Set if EKF's vertical position (absolute) estimate is good.''')
EKF_POS_VERT_AGL = 64 # Set if EKF's vertical position (above ground) estimate is good.
enums['EKF_STATUS_FLAGS'][64] = EnumEntry('EKF_POS_VERT_AGL', '''Set if EKF's vertical position (above ground) estimate is good.''')
EKF_CONST_POS_MODE = 128 # EKF is in constant position mode and does not know it's absolute or
                        # relative position.
enums['EKF_STATUS_FLAGS'][128] = EnumEntry('EKF_CONST_POS_MODE', '''EKF is in constant position mode and does not know it's absolute or relative position.''')
EKF_PRED_POS_HORIZ_REL = 256 # Set if EKF's predicted horizontal position (relative) estimate is
                        # good.
enums['EKF_STATUS_FLAGS'][256] = EnumEntry('EKF_PRED_POS_HORIZ_REL', '''Set if EKF's predicted horizontal position (relative) estimate is good.''')
EKF_PRED_POS_HORIZ_ABS = 512 # Set if EKF's predicted horizontal position (absolute) estimate is
                        # good.
enums['EKF_STATUS_FLAGS'][512] = EnumEntry('EKF_PRED_POS_HORIZ_ABS', '''Set if EKF's predicted horizontal position (absolute) estimate is good.''')
EKF_UNINITIALIZED = 1024 # Set if EKF has never been healthy.
enums['EKF_STATUS_FLAGS'][1024] = EnumEntry('EKF_UNINITIALIZED', '''Set if EKF has never been healthy.''')
EKF_STATUS_FLAGS_ENUM_END = 1025 # 
enums['EKF_STATUS_FLAGS'][1025] = EnumEntry('EKF_STATUS_FLAGS_ENUM_END', '''''')

# PID_TUNING_AXIS
enums['PID_TUNING_AXIS'] = {}
PID_TUNING_ROLL = 1 # 
enums['PID_TUNING_AXIS'][1] = EnumEntry('PID_TUNING_ROLL', '''''')
PID_TUNING_PITCH = 2 # 
enums['PID_TUNING_AXIS'][2] = EnumEntry('PID_TUNING_PITCH', '''''')
PID_TUNING_YAW = 3 # 
enums['PID_TUNING_AXIS'][3] = EnumEntry('PID_TUNING_YAW', '''''')
PID_TUNING_ACCZ = 4 # 
enums['PID_TUNING_AXIS'][4] = EnumEntry('PID_TUNING_ACCZ', '''''')
PID_TUNING_STEER = 5 # 
enums['PID_TUNING_AXIS'][5] = EnumEntry('PID_TUNING_STEER', '''''')
PID_TUNING_LANDING = 6 # 
enums['PID_TUNING_AXIS'][6] = EnumEntry('PID_TUNING_LANDING', '''''')
PID_TUNING_AXIS_ENUM_END = 7 # 
enums['PID_TUNING_AXIS'][7] = EnumEntry('PID_TUNING_AXIS_ENUM_END', '''''')

# MAG_CAL_STATUS
enums['MAG_CAL_STATUS'] = {}
MAG_CAL_NOT_STARTED = 0 # 
enums['MAG_CAL_STATUS'][0] = EnumEntry('MAG_CAL_NOT_STARTED', '''''')
MAG_CAL_WAITING_TO_START = 1 # 
enums['MAG_CAL_STATUS'][1] = EnumEntry('MAG_CAL_WAITING_TO_START', '''''')
MAG_CAL_RUNNING_STEP_ONE = 2 # 
enums['MAG_CAL_STATUS'][2] = EnumEntry('MAG_CAL_RUNNING_STEP_ONE', '''''')
MAG_CAL_RUNNING_STEP_TWO = 3 # 
enums['MAG_CAL_STATUS'][3] = EnumEntry('MAG_CAL_RUNNING_STEP_TWO', '''''')
MAG_CAL_SUCCESS = 4 # 
enums['MAG_CAL_STATUS'][4] = EnumEntry('MAG_CAL_SUCCESS', '''''')
MAG_CAL_FAILED = 5 # 
enums['MAG_CAL_STATUS'][5] = EnumEntry('MAG_CAL_FAILED', '''''')
MAG_CAL_BAD_ORIENTATION = 6 # 
enums['MAG_CAL_STATUS'][6] = EnumEntry('MAG_CAL_BAD_ORIENTATION', '''''')
MAG_CAL_BAD_RADIUS = 7 # 
enums['MAG_CAL_STATUS'][7] = EnumEntry('MAG_CAL_BAD_RADIUS', '''''')
MAG_CAL_STATUS_ENUM_END = 8 # 
enums['MAG_CAL_STATUS'][8] = EnumEntry('MAG_CAL_STATUS_ENUM_END', '''''')

# MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS
enums['MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS'] = {}
MAV_REMOTE_LOG_DATA_BLOCK_STOP = 2147483645 # UAV to stop sending DataFlash blocks.
enums['MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS'][2147483645] = EnumEntry('MAV_REMOTE_LOG_DATA_BLOCK_STOP', '''UAV to stop sending DataFlash blocks.''')
MAV_REMOTE_LOG_DATA_BLOCK_START = 2147483646 # UAV to start sending DataFlash blocks.
enums['MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS'][2147483646] = EnumEntry('MAV_REMOTE_LOG_DATA_BLOCK_START', '''UAV to start sending DataFlash blocks.''')
MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS_ENUM_END = 2147483647 # 
enums['MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS'][2147483647] = EnumEntry('MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS_ENUM_END', '''''')

# MAV_REMOTE_LOG_DATA_BLOCK_STATUSES
enums['MAV_REMOTE_LOG_DATA_BLOCK_STATUSES'] = {}
MAV_REMOTE_LOG_DATA_BLOCK_NACK = 0 # This block has NOT been received.
enums['MAV_REMOTE_LOG_DATA_BLOCK_STATUSES'][0] = EnumEntry('MAV_REMOTE_LOG_DATA_BLOCK_NACK', '''This block has NOT been received.''')
MAV_REMOTE_LOG_DATA_BLOCK_ACK = 1 # This block has been received.
enums['MAV_REMOTE_LOG_DATA_BLOCK_STATUSES'][1] = EnumEntry('MAV_REMOTE_LOG_DATA_BLOCK_ACK', '''This block has been received.''')
MAV_REMOTE_LOG_DATA_BLOCK_STATUSES_ENUM_END = 2 # 
enums['MAV_REMOTE_LOG_DATA_BLOCK_STATUSES'][2] = EnumEntry('MAV_REMOTE_LOG_DATA_BLOCK_STATUSES_ENUM_END', '''''')

# DEVICE_OP_BUSTYPE
enums['DEVICE_OP_BUSTYPE'] = {}
DEVICE_OP_BUSTYPE_I2C = 0 # I2C Device operation.
enums['DEVICE_OP_BUSTYPE'][0] = EnumEntry('DEVICE_OP_BUSTYPE_I2C', '''I2C Device operation.''')
DEVICE_OP_BUSTYPE_SPI = 1 # SPI Device operation.
enums['DEVICE_OP_BUSTYPE'][1] = EnumEntry('DEVICE_OP_BUSTYPE_SPI', '''SPI Device operation.''')
DEVICE_OP_BUSTYPE_ENUM_END = 2 # 
enums['DEVICE_OP_BUSTYPE'][2] = EnumEntry('DEVICE_OP_BUSTYPE_ENUM_END', '''''')

# DEEPSTALL_STAGE
enums['DEEPSTALL_STAGE'] = {}
DEEPSTALL_STAGE_FLY_TO_LANDING = 0 # Flying to the landing point.
enums['DEEPSTALL_STAGE'][0] = EnumEntry('DEEPSTALL_STAGE_FLY_TO_LANDING', '''Flying to the landing point.''')
DEEPSTALL_STAGE_ESTIMATE_WIND = 1 # Building an estimate of the wind.
enums['DEEPSTALL_STAGE'][1] = EnumEntry('DEEPSTALL_STAGE_ESTIMATE_WIND', '''Building an estimate of the wind.''')
DEEPSTALL_STAGE_WAIT_FOR_BREAKOUT = 2 # Waiting to breakout of the loiter to fly the approach.
enums['DEEPSTALL_STAGE'][2] = EnumEntry('DEEPSTALL_STAGE_WAIT_FOR_BREAKOUT', '''Waiting to breakout of the loiter to fly the approach.''')
DEEPSTALL_STAGE_FLY_TO_ARC = 3 # Flying to the first arc point to turn around to the landing point.
enums['DEEPSTALL_STAGE'][3] = EnumEntry('DEEPSTALL_STAGE_FLY_TO_ARC', '''Flying to the first arc point to turn around to the landing point.''')
DEEPSTALL_STAGE_ARC = 4 # Turning around back to the deepstall landing point.
enums['DEEPSTALL_STAGE'][4] = EnumEntry('DEEPSTALL_STAGE_ARC', '''Turning around back to the deepstall landing point.''')
DEEPSTALL_STAGE_APPROACH = 5 # Approaching the landing point.
enums['DEEPSTALL_STAGE'][5] = EnumEntry('DEEPSTALL_STAGE_APPROACH', '''Approaching the landing point.''')
DEEPSTALL_STAGE_LAND = 6 # Stalling and steering towards the land point.
enums['DEEPSTALL_STAGE'][6] = EnumEntry('DEEPSTALL_STAGE_LAND', '''Stalling and steering towards the land point.''')
DEEPSTALL_STAGE_ENUM_END = 7 # 
enums['DEEPSTALL_STAGE'][7] = EnumEntry('DEEPSTALL_STAGE_ENUM_END', '''''')

# PLANE_MODE
enums['PLANE_MODE'] = {}
PLANE_MODE_MANUAL = 0 # 
enums['PLANE_MODE'][0] = EnumEntry('PLANE_MODE_MANUAL', '''''')
PLANE_MODE_CIRCLE = 1 # 
enums['PLANE_MODE'][1] = EnumEntry('PLANE_MODE_CIRCLE', '''''')
PLANE_MODE_STABILIZE = 2 # 
enums['PLANE_MODE'][2] = EnumEntry('PLANE_MODE_STABILIZE', '''''')
PLANE_MODE_TRAINING = 3 # 
enums['PLANE_MODE'][3] = EnumEntry('PLANE_MODE_TRAINING', '''''')
PLANE_MODE_ACRO = 4 # 
enums['PLANE_MODE'][4] = EnumEntry('PLANE_MODE_ACRO', '''''')
PLANE_MODE_FLY_BY_WIRE_A = 5 # 
enums['PLANE_MODE'][5] = EnumEntry('PLANE_MODE_FLY_BY_WIRE_A', '''''')
PLANE_MODE_FLY_BY_WIRE_B = 6 # 
enums['PLANE_MODE'][6] = EnumEntry('PLANE_MODE_FLY_BY_WIRE_B', '''''')
PLANE_MODE_CRUISE = 7 # 
enums['PLANE_MODE'][7] = EnumEntry('PLANE_MODE_CRUISE', '''''')
PLANE_MODE_AUTOTUNE = 8 # 
enums['PLANE_MODE'][8] = EnumEntry('PLANE_MODE_AUTOTUNE', '''''')
PLANE_MODE_AUTO = 10 # 
enums['PLANE_MODE'][10] = EnumEntry('PLANE_MODE_AUTO', '''''')
PLANE_MODE_RTL = 11 # 
enums['PLANE_MODE'][11] = EnumEntry('PLANE_MODE_RTL', '''''')
PLANE_MODE_LOITER = 12 # 
enums['PLANE_MODE'][12] = EnumEntry('PLANE_MODE_LOITER', '''''')
PLANE_MODE_TAKEOFF = 13 # 
enums['PLANE_MODE'][13] = EnumEntry('PLANE_MODE_TAKEOFF', '''''')
PLANE_MODE_AVOID_ADSB = 14 # 
enums['PLANE_MODE'][14] = EnumEntry('PLANE_MODE_AVOID_ADSB', '''''')
PLANE_MODE_GUIDED = 15 # 
enums['PLANE_MODE'][15] = EnumEntry('PLANE_MODE_GUIDED', '''''')
PLANE_MODE_INITIALIZING = 16 # 
enums['PLANE_MODE'][16] = EnumEntry('PLANE_MODE_INITIALIZING', '''''')
PLANE_MODE_QSTABILIZE = 17 # 
enums['PLANE_MODE'][17] = EnumEntry('PLANE_MODE_QSTABILIZE', '''''')
PLANE_MODE_QHOVER = 18 # 
enums['PLANE_MODE'][18] = EnumEntry('PLANE_MODE_QHOVER', '''''')
PLANE_MODE_QLOITER = 19 # 
enums['PLANE_MODE'][19] = EnumEntry('PLANE_MODE_QLOITER', '''''')
PLANE_MODE_QLAND = 20 # 
enums['PLANE_MODE'][20] = EnumEntry('PLANE_MODE_QLAND', '''''')
PLANE_MODE_QRTL = 21 # 
enums['PLANE_MODE'][21] = EnumEntry('PLANE_MODE_QRTL', '''''')
PLANE_MODE_QAUTOTUNE = 22 # 
enums['PLANE_MODE'][22] = EnumEntry('PLANE_MODE_QAUTOTUNE', '''''')
PLANE_MODE_ENUM_END = 23 # 
enums['PLANE_MODE'][23] = EnumEntry('PLANE_MODE_ENUM_END', '''''')

# COPTER_MODE
enums['COPTER_MODE'] = {}
COPTER_MODE_STABILIZE = 0 # 
enums['COPTER_MODE'][0] = EnumEntry('COPTER_MODE_STABILIZE', '''''')
COPTER_MODE_ACRO = 1 # 
enums['COPTER_MODE'][1] = EnumEntry('COPTER_MODE_ACRO', '''''')
COPTER_MODE_ALT_HOLD = 2 # 
enums['COPTER_MODE'][2] = EnumEntry('COPTER_MODE_ALT_HOLD', '''''')
COPTER_MODE_AUTO = 3 # 
enums['COPTER_MODE'][3] = EnumEntry('COPTER_MODE_AUTO', '''''')
COPTER_MODE_GUIDED = 4 # 
enums['COPTER_MODE'][4] = EnumEntry('COPTER_MODE_GUIDED', '''''')
COPTER_MODE_LOITER = 5 # 
enums['COPTER_MODE'][5] = EnumEntry('COPTER_MODE_LOITER', '''''')
COPTER_MODE_RTL = 6 # 
enums['COPTER_MODE'][6] = EnumEntry('COPTER_MODE_RTL', '''''')
COPTER_MODE_CIRCLE = 7 # 
enums['COPTER_MODE'][7] = EnumEntry('COPTER_MODE_CIRCLE', '''''')
COPTER_MODE_LAND = 9 # 
enums['COPTER_MODE'][9] = EnumEntry('COPTER_MODE_LAND', '''''')
COPTER_MODE_DRIFT = 11 # 
enums['COPTER_MODE'][11] = EnumEntry('COPTER_MODE_DRIFT', '''''')
COPTER_MODE_SPORT = 13 # 
enums['COPTER_MODE'][13] = EnumEntry('COPTER_MODE_SPORT', '''''')
COPTER_MODE_FLIP = 14 # 
enums['COPTER_MODE'][14] = EnumEntry('COPTER_MODE_FLIP', '''''')
COPTER_MODE_AUTOTUNE = 15 # 
enums['COPTER_MODE'][15] = EnumEntry('COPTER_MODE_AUTOTUNE', '''''')
COPTER_MODE_POSHOLD = 16 # 
enums['COPTER_MODE'][16] = EnumEntry('COPTER_MODE_POSHOLD', '''''')
COPTER_MODE_BRAKE = 17 # 
enums['COPTER_MODE'][17] = EnumEntry('COPTER_MODE_BRAKE', '''''')
COPTER_MODE_THROW = 18 # 
enums['COPTER_MODE'][18] = EnumEntry('COPTER_MODE_THROW', '''''')
COPTER_MODE_AVOID_ADSB = 19 # 
enums['COPTER_MODE'][19] = EnumEntry('COPTER_MODE_AVOID_ADSB', '''''')
COPTER_MODE_GUIDED_NOGPS = 20 # 
enums['COPTER_MODE'][20] = EnumEntry('COPTER_MODE_GUIDED_NOGPS', '''''')
COPTER_MODE_SMART_RTL = 21 # 
enums['COPTER_MODE'][21] = EnumEntry('COPTER_MODE_SMART_RTL', '''''')
COPTER_MODE_ENUM_END = 22 # 
enums['COPTER_MODE'][22] = EnumEntry('COPTER_MODE_ENUM_END', '''''')

# SUB_MODE
enums['SUB_MODE'] = {}
SUB_MODE_STABILIZE = 0 # 
enums['SUB_MODE'][0] = EnumEntry('SUB_MODE_STABILIZE', '''''')
SUB_MODE_ACRO = 1 # 
enums['SUB_MODE'][1] = EnumEntry('SUB_MODE_ACRO', '''''')
SUB_MODE_ALT_HOLD = 2 # 
enums['SUB_MODE'][2] = EnumEntry('SUB_MODE_ALT_HOLD', '''''')
SUB_MODE_AUTO = 3 # 
enums['SUB_MODE'][3] = EnumEntry('SUB_MODE_AUTO', '''''')
SUB_MODE_GUIDED = 4 # 
enums['SUB_MODE'][4] = EnumEntry('SUB_MODE_GUIDED', '''''')
SUB_MODE_CIRCLE = 7 # 
enums['SUB_MODE'][7] = EnumEntry('SUB_MODE_CIRCLE', '''''')
SUB_MODE_SURFACE = 9 # 
enums['SUB_MODE'][9] = EnumEntry('SUB_MODE_SURFACE', '''''')
SUB_MODE_POSHOLD = 16 # 
enums['SUB_MODE'][16] = EnumEntry('SUB_MODE_POSHOLD', '''''')
SUB_MODE_MANUAL = 19 # 
enums['SUB_MODE'][19] = EnumEntry('SUB_MODE_MANUAL', '''''')
SUB_MODE_ENUM_END = 20 # 
enums['SUB_MODE'][20] = EnumEntry('SUB_MODE_ENUM_END', '''''')

# ROVER_MODE
enums['ROVER_MODE'] = {}
ROVER_MODE_MANUAL = 0 # 
enums['ROVER_MODE'][0] = EnumEntry('ROVER_MODE_MANUAL', '''''')
ROVER_MODE_ACRO = 1 # 
enums['ROVER_MODE'][1] = EnumEntry('ROVER_MODE_ACRO', '''''')
ROVER_MODE_STEERING = 3 # 
enums['ROVER_MODE'][3] = EnumEntry('ROVER_MODE_STEERING', '''''')
ROVER_MODE_HOLD = 4 # 
enums['ROVER_MODE'][4] = EnumEntry('ROVER_MODE_HOLD', '''''')
ROVER_MODE_LOITER = 5 # 
enums['ROVER_MODE'][5] = EnumEntry('ROVER_MODE_LOITER', '''''')
ROVER_MODE_AUTO = 10 # 
enums['ROVER_MODE'][10] = EnumEntry('ROVER_MODE_AUTO', '''''')
ROVER_MODE_RTL = 11 # 
enums['ROVER_MODE'][11] = EnumEntry('ROVER_MODE_RTL', '''''')
ROVER_MODE_SMART_RTL = 12 # 
enums['ROVER_MODE'][12] = EnumEntry('ROVER_MODE_SMART_RTL', '''''')
ROVER_MODE_GUIDED = 15 # 
enums['ROVER_MODE'][15] = EnumEntry('ROVER_MODE_GUIDED', '''''')
ROVER_MODE_INITIALIZING = 16 # 
enums['ROVER_MODE'][16] = EnumEntry('ROVER_MODE_INITIALIZING', '''''')
ROVER_MODE_ENUM_END = 17 # 
enums['ROVER_MODE'][17] = EnumEntry('ROVER_MODE_ENUM_END', '''''')

# TRACKER_MODE
enums['TRACKER_MODE'] = {}
TRACKER_MODE_MANUAL = 0 # 
enums['TRACKER_MODE'][0] = EnumEntry('TRACKER_MODE_MANUAL', '''''')
TRACKER_MODE_STOP = 1 # 
enums['TRACKER_MODE'][1] = EnumEntry('TRACKER_MODE_STOP', '''''')
TRACKER_MODE_SCAN = 2 # 
enums['TRACKER_MODE'][2] = EnumEntry('TRACKER_MODE_SCAN', '''''')
TRACKER_MODE_SERVO_TEST = 3 # 
enums['TRACKER_MODE'][3] = EnumEntry('TRACKER_MODE_SERVO_TEST', '''''')
TRACKER_MODE_AUTO = 10 # 
enums['TRACKER_MODE'][10] = EnumEntry('TRACKER_MODE_AUTO', '''''')
TRACKER_MODE_INITIALIZING = 16 # 
enums['TRACKER_MODE'][16] = EnumEntry('TRACKER_MODE_INITIALIZING', '''''')
TRACKER_MODE_ENUM_END = 17 # 
enums['TRACKER_MODE'][17] = EnumEntry('TRACKER_MODE_ENUM_END', '''''')

# message IDs
MAVLINK_MSG_ID_BAD_DATA = -1
MAVLINK_MSG_ID_SENSOR_OFFSETS = 150
MAVLINK_MSG_ID_SET_MAG_OFFSETS = 151
MAVLINK_MSG_ID_MEMINFO = 152
MAVLINK_MSG_ID_AP_ADC = 153
MAVLINK_MSG_ID_DIGICAM_CONFIGURE = 154
MAVLINK_MSG_ID_DIGICAM_CONTROL = 155
MAVLINK_MSG_ID_MOUNT_CONFIGURE = 156
MAVLINK_MSG_ID_MOUNT_CONTROL = 157
MAVLINK_MSG_ID_MOUNT_STATUS = 158
MAVLINK_MSG_ID_FENCE_POINT = 160
MAVLINK_MSG_ID_FENCE_FETCH_POINT = 161
MAVLINK_MSG_ID_AHRS = 163
MAVLINK_MSG_ID_SIMSTATE = 164
MAVLINK_MSG_ID_HWSTATUS = 165
MAVLINK_MSG_ID_RADIO = 166
MAVLINK_MSG_ID_LIMITS_STATUS = 167
MAVLINK_MSG_ID_WIND = 168
MAVLINK_MSG_ID_DATA16 = 169
MAVLINK_MSG_ID_DATA32 = 170
MAVLINK_MSG_ID_DATA64 = 171
MAVLINK_MSG_ID_DATA96 = 172
MAVLINK_MSG_ID_RANGEFINDER = 173
MAVLINK_MSG_ID_AIRSPEED_AUTOCAL = 174
MAVLINK_MSG_ID_RALLY_POINT = 175
MAVLINK_MSG_ID_RALLY_FETCH_POINT = 176
MAVLINK_MSG_ID_COMPASSMOT_STATUS = 177
MAVLINK_MSG_ID_AHRS2 = 178
MAVLINK_MSG_ID_CAMERA_STATUS = 179
MAVLINK_MSG_ID_CAMERA_FEEDBACK = 180
MAVLINK_MSG_ID_BATTERY2 = 181
MAVLINK_MSG_ID_AHRS3 = 182
MAVLINK_MSG_ID_AUTOPILOT_VERSION_REQUEST = 183
MAVLINK_MSG_ID_REMOTE_LOG_DATA_BLOCK = 184
MAVLINK_MSG_ID_REMOTE_LOG_BLOCK_STATUS = 185
MAVLINK_MSG_ID_LED_CONTROL = 186
MAVLINK_MSG_ID_MAG_CAL_PROGRESS = 191
MAVLINK_MSG_ID_MAG_CAL_REPORT = 192
MAVLINK_MSG_ID_EKF_STATUS_REPORT = 193
MAVLINK_MSG_ID_PID_TUNING = 194
MAVLINK_MSG_ID_DEEPSTALL = 195
MAVLINK_MSG_ID_GIMBAL_REPORT = 200
MAVLINK_MSG_ID_GIMBAL_CONTROL = 201
MAVLINK_MSG_ID_GIMBAL_TORQUE_CMD_REPORT = 214
MAVLINK_MSG_ID_GOPRO_HEARTBEAT = 215
MAVLINK_MSG_ID_GOPRO_GET_REQUEST = 216
MAVLINK_MSG_ID_GOPRO_GET_RESPONSE = 217
MAVLINK_MSG_ID_GOPRO_SET_REQUEST = 218
MAVLINK_MSG_ID_GOPRO_SET_RESPONSE = 219
MAVLINK_MSG_ID_EFI_STATUS = 225
MAVLINK_MSG_ID_RPM = 226

class MAVLink_sensor_offsets_message(MAVLink_message):
        '''
        Offsets and calibrations values for hardware sensors. This
        makes it easier to debug the calibration process.
        '''
        id = MAVLINK_MSG_ID_SENSOR_OFFSETS
        name = 'SENSOR_OFFSETS'
        fieldnames = ['mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z', 'mag_declination', 'raw_press', 'raw_temp', 'gyro_cal_x', 'gyro_cal_y', 'gyro_cal_z', 'accel_cal_x', 'accel_cal_y', 'accel_cal_z']
        ordered_fieldnames = ['mag_declination', 'raw_press', 'raw_temp', 'gyro_cal_x', 'gyro_cal_y', 'gyro_cal_z', 'accel_cal_x', 'accel_cal_y', 'accel_cal_z', 'mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z']
        fieldtypes = ['int16_t', 'int16_t', 'int16_t', 'float', 'int32_t', 'int32_t', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"mag_declination": "rad"}
        format = '<fiiffffffhhh'
        native_format = bytearray('<fiiffffffhhh', 'ascii')
        orders = [9, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 134
        unpacker = struct.Struct('<fiiffffffhhh')
        instance_field = None
        instance_offset = -1

        def __init__(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z):
                MAVLink_message.__init__(self, MAVLink_sensor_offsets_message.id, MAVLink_sensor_offsets_message.name)
                self._fieldnames = MAVLink_sensor_offsets_message.fieldnames
                self._instance_field = MAVLink_sensor_offsets_message.instance_field
                self._instance_offset = MAVLink_sensor_offsets_message.instance_offset
                self.mag_ofs_x = mag_ofs_x
                self.mag_ofs_y = mag_ofs_y
                self.mag_ofs_z = mag_ofs_z
                self.mag_declination = mag_declination
                self.raw_press = raw_press
                self.raw_temp = raw_temp
                self.gyro_cal_x = gyro_cal_x
                self.gyro_cal_y = gyro_cal_y
                self.gyro_cal_z = gyro_cal_z
                self.accel_cal_x = accel_cal_x
                self.accel_cal_y = accel_cal_y
                self.accel_cal_z = accel_cal_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 134, struct.pack('<fiiffffffhhh', self.mag_declination, self.raw_press, self.raw_temp, self.gyro_cal_x, self.gyro_cal_y, self.gyro_cal_z, self.accel_cal_x, self.accel_cal_y, self.accel_cal_z, self.mag_ofs_x, self.mag_ofs_y, self.mag_ofs_z), force_mavlink1=force_mavlink1)

class MAVLink_set_mag_offsets_message(MAVLink_message):
        '''
        Set the magnetometer offsets
        '''
        id = MAVLINK_MSG_ID_SET_MAG_OFFSETS
        name = 'SET_MAG_OFFSETS'
        fieldnames = ['target_system', 'target_component', 'mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z']
        ordered_fieldnames = ['mag_ofs_x', 'mag_ofs_y', 'mag_ofs_z', 'target_system', 'target_component']
        fieldtypes = ['uint8_t', 'uint8_t', 'int16_t', 'int16_t', 'int16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<hhhBB'
        native_format = bytearray('<hhhBB', 'ascii')
        orders = [3, 4, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 219
        unpacker = struct.Struct('<hhhBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z):
                MAVLink_message.__init__(self, MAVLink_set_mag_offsets_message.id, MAVLink_set_mag_offsets_message.name)
                self._fieldnames = MAVLink_set_mag_offsets_message.fieldnames
                self._instance_field = MAVLink_set_mag_offsets_message.instance_field
                self._instance_offset = MAVLink_set_mag_offsets_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.mag_ofs_x = mag_ofs_x
                self.mag_ofs_y = mag_ofs_y
                self.mag_ofs_z = mag_ofs_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 219, struct.pack('<hhhBB', self.mag_ofs_x, self.mag_ofs_y, self.mag_ofs_z, self.target_system, self.target_component), force_mavlink1=force_mavlink1)

class MAVLink_meminfo_message(MAVLink_message):
        '''
        State of APM memory.
        '''
        id = MAVLINK_MSG_ID_MEMINFO
        name = 'MEMINFO'
        fieldnames = ['brkval', 'freemem']
        ordered_fieldnames = ['brkval', 'freemem']
        fieldtypes = ['uint16_t', 'uint16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"freemem": "bytes"}
        format = '<HH'
        native_format = bytearray('<HH', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 208
        unpacker = struct.Struct('<HH')
        instance_field = None
        instance_offset = -1

        def __init__(self, brkval, freemem):
                MAVLink_message.__init__(self, MAVLink_meminfo_message.id, MAVLink_meminfo_message.name)
                self._fieldnames = MAVLink_meminfo_message.fieldnames
                self._instance_field = MAVLink_meminfo_message.instance_field
                self._instance_offset = MAVLink_meminfo_message.instance_offset
                self.brkval = brkval
                self.freemem = freemem

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 208, struct.pack('<HH', self.brkval, self.freemem), force_mavlink1=force_mavlink1)

class MAVLink_ap_adc_message(MAVLink_message):
        '''
        Raw ADC output.
        '''
        id = MAVLINK_MSG_ID_AP_ADC
        name = 'AP_ADC'
        fieldnames = ['adc1', 'adc2', 'adc3', 'adc4', 'adc5', 'adc6']
        ordered_fieldnames = ['adc1', 'adc2', 'adc3', 'adc4', 'adc5', 'adc6']
        fieldtypes = ['uint16_t', 'uint16_t', 'uint16_t', 'uint16_t', 'uint16_t', 'uint16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<HHHHHH'
        native_format = bytearray('<HHHHHH', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 188
        unpacker = struct.Struct('<HHHHHH')
        instance_field = None
        instance_offset = -1

        def __init__(self, adc1, adc2, adc3, adc4, adc5, adc6):
                MAVLink_message.__init__(self, MAVLink_ap_adc_message.id, MAVLink_ap_adc_message.name)
                self._fieldnames = MAVLink_ap_adc_message.fieldnames
                self._instance_field = MAVLink_ap_adc_message.instance_field
                self._instance_offset = MAVLink_ap_adc_message.instance_offset
                self.adc1 = adc1
                self.adc2 = adc2
                self.adc3 = adc3
                self.adc4 = adc4
                self.adc5 = adc5
                self.adc6 = adc6

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 188, struct.pack('<HHHHHH', self.adc1, self.adc2, self.adc3, self.adc4, self.adc5, self.adc6), force_mavlink1=force_mavlink1)

class MAVLink_digicam_configure_message(MAVLink_message):
        '''
        Configure on-board Camera Control System.
        '''
        id = MAVLINK_MSG_ID_DIGICAM_CONFIGURE
        name = 'DIGICAM_CONFIGURE'
        fieldnames = ['target_system', 'target_component', 'mode', 'shutter_speed', 'aperture', 'iso', 'exposure_type', 'command_id', 'engine_cut_off', 'extra_param', 'extra_value']
        ordered_fieldnames = ['extra_value', 'shutter_speed', 'target_system', 'target_component', 'mode', 'aperture', 'iso', 'exposure_type', 'command_id', 'engine_cut_off', 'extra_param']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint16_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"engine_cut_off": "ds"}
        format = '<fHBBBBBBBBB'
        native_format = bytearray('<fHBBBBBBBBB', 'ascii')
        orders = [2, 3, 4, 1, 5, 6, 7, 8, 9, 10, 0]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 84
        unpacker = struct.Struct('<fHBBBBBBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value):
                MAVLink_message.__init__(self, MAVLink_digicam_configure_message.id, MAVLink_digicam_configure_message.name)
                self._fieldnames = MAVLink_digicam_configure_message.fieldnames
                self._instance_field = MAVLink_digicam_configure_message.instance_field
                self._instance_offset = MAVLink_digicam_configure_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.mode = mode
                self.shutter_speed = shutter_speed
                self.aperture = aperture
                self.iso = iso
                self.exposure_type = exposure_type
                self.command_id = command_id
                self.engine_cut_off = engine_cut_off
                self.extra_param = extra_param
                self.extra_value = extra_value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 84, struct.pack('<fHBBBBBBBBB', self.extra_value, self.shutter_speed, self.target_system, self.target_component, self.mode, self.aperture, self.iso, self.exposure_type, self.command_id, self.engine_cut_off, self.extra_param), force_mavlink1=force_mavlink1)

class MAVLink_digicam_control_message(MAVLink_message):
        '''
        Control on-board Camera Control System to take shots.
        '''
        id = MAVLINK_MSG_ID_DIGICAM_CONTROL
        name = 'DIGICAM_CONTROL'
        fieldnames = ['target_system', 'target_component', 'session', 'zoom_pos', 'zoom_step', 'focus_lock', 'shot', 'command_id', 'extra_param', 'extra_value']
        ordered_fieldnames = ['extra_value', 'target_system', 'target_component', 'session', 'zoom_pos', 'zoom_step', 'focus_lock', 'shot', 'command_id', 'extra_param']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'int8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<fBBBBbBBBB'
        native_format = bytearray('<fBBBBbBBBB', 'ascii')
        orders = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 22
        unpacker = struct.Struct('<fBBBBbBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value):
                MAVLink_message.__init__(self, MAVLink_digicam_control_message.id, MAVLink_digicam_control_message.name)
                self._fieldnames = MAVLink_digicam_control_message.fieldnames
                self._instance_field = MAVLink_digicam_control_message.instance_field
                self._instance_offset = MAVLink_digicam_control_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.session = session
                self.zoom_pos = zoom_pos
                self.zoom_step = zoom_step
                self.focus_lock = focus_lock
                self.shot = shot
                self.command_id = command_id
                self.extra_param = extra_param
                self.extra_value = extra_value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 22, struct.pack('<fBBBBbBBBB', self.extra_value, self.target_system, self.target_component, self.session, self.zoom_pos, self.zoom_step, self.focus_lock, self.shot, self.command_id, self.extra_param), force_mavlink1=force_mavlink1)

class MAVLink_mount_configure_message(MAVLink_message):
        '''
        Message to configure a camera mount, directional antenna, etc.
        '''
        id = MAVLINK_MSG_ID_MOUNT_CONFIGURE
        name = 'MOUNT_CONFIGURE'
        fieldnames = ['target_system', 'target_component', 'mount_mode', 'stab_roll', 'stab_pitch', 'stab_yaw']
        ordered_fieldnames = ['target_system', 'target_component', 'mount_mode', 'stab_roll', 'stab_pitch', 'stab_yaw']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"mount_mode": "MAV_MOUNT_MODE"}
        fieldunits_by_name = {}
        format = '<BBBBBB'
        native_format = bytearray('<BBBBBB', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 19
        unpacker = struct.Struct('<BBBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw):
                MAVLink_message.__init__(self, MAVLink_mount_configure_message.id, MAVLink_mount_configure_message.name)
                self._fieldnames = MAVLink_mount_configure_message.fieldnames
                self._instance_field = MAVLink_mount_configure_message.instance_field
                self._instance_offset = MAVLink_mount_configure_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.mount_mode = mount_mode
                self.stab_roll = stab_roll
                self.stab_pitch = stab_pitch
                self.stab_yaw = stab_yaw

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 19, struct.pack('<BBBBBB', self.target_system, self.target_component, self.mount_mode, self.stab_roll, self.stab_pitch, self.stab_yaw), force_mavlink1=force_mavlink1)

class MAVLink_mount_control_message(MAVLink_message):
        '''
        Message to control a camera mount, directional antenna, etc.
        '''
        id = MAVLINK_MSG_ID_MOUNT_CONTROL
        name = 'MOUNT_CONTROL'
        fieldnames = ['target_system', 'target_component', 'input_a', 'input_b', 'input_c', 'save_position']
        ordered_fieldnames = ['input_a', 'input_b', 'input_c', 'target_system', 'target_component', 'save_position']
        fieldtypes = ['uint8_t', 'uint8_t', 'int32_t', 'int32_t', 'int32_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<iiiBBB'
        native_format = bytearray('<iiiBBB', 'ascii')
        orders = [3, 4, 0, 1, 2, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 21
        unpacker = struct.Struct('<iiiBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, input_a, input_b, input_c, save_position):
                MAVLink_message.__init__(self, MAVLink_mount_control_message.id, MAVLink_mount_control_message.name)
                self._fieldnames = MAVLink_mount_control_message.fieldnames
                self._instance_field = MAVLink_mount_control_message.instance_field
                self._instance_offset = MAVLink_mount_control_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.input_a = input_a
                self.input_b = input_b
                self.input_c = input_c
                self.save_position = save_position

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 21, struct.pack('<iiiBBB', self.input_a, self.input_b, self.input_c, self.target_system, self.target_component, self.save_position), force_mavlink1=force_mavlink1)

class MAVLink_mount_status_message(MAVLink_message):
        '''
        Message with some status from APM to GCS about camera or
        antenna mount.
        '''
        id = MAVLINK_MSG_ID_MOUNT_STATUS
        name = 'MOUNT_STATUS'
        fieldnames = ['target_system', 'target_component', 'pointing_a', 'pointing_b', 'pointing_c']
        ordered_fieldnames = ['pointing_a', 'pointing_b', 'pointing_c', 'target_system', 'target_component']
        fieldtypes = ['uint8_t', 'uint8_t', 'int32_t', 'int32_t', 'int32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"pointing_a": "cdeg", "pointing_b": "cdeg", "pointing_c": "cdeg"}
        format = '<iiiBB'
        native_format = bytearray('<iiiBB', 'ascii')
        orders = [3, 4, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 134
        unpacker = struct.Struct('<iiiBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, pointing_a, pointing_b, pointing_c):
                MAVLink_message.__init__(self, MAVLink_mount_status_message.id, MAVLink_mount_status_message.name)
                self._fieldnames = MAVLink_mount_status_message.fieldnames
                self._instance_field = MAVLink_mount_status_message.instance_field
                self._instance_offset = MAVLink_mount_status_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.pointing_a = pointing_a
                self.pointing_b = pointing_b
                self.pointing_c = pointing_c

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 134, struct.pack('<iiiBB', self.pointing_a, self.pointing_b, self.pointing_c, self.target_system, self.target_component), force_mavlink1=force_mavlink1)

class MAVLink_fence_point_message(MAVLink_message):
        '''
        A fence point. Used to set a point when from GCS -> MAV. Also
        used to return a point from MAV -> GCS.
        '''
        id = MAVLINK_MSG_ID_FENCE_POINT
        name = 'FENCE_POINT'
        fieldnames = ['target_system', 'target_component', 'idx', 'count', 'lat', 'lng']
        ordered_fieldnames = ['lat', 'lng', 'target_system', 'target_component', 'idx', 'count']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"lat": "deg", "lng": "deg"}
        format = '<ffBBBB'
        native_format = bytearray('<ffBBBB', 'ascii')
        orders = [2, 3, 4, 5, 0, 1]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 78
        unpacker = struct.Struct('<ffBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, idx, count, lat, lng):
                MAVLink_message.__init__(self, MAVLink_fence_point_message.id, MAVLink_fence_point_message.name)
                self._fieldnames = MAVLink_fence_point_message.fieldnames
                self._instance_field = MAVLink_fence_point_message.instance_field
                self._instance_offset = MAVLink_fence_point_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx
                self.count = count
                self.lat = lat
                self.lng = lng

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 78, struct.pack('<ffBBBB', self.lat, self.lng, self.target_system, self.target_component, self.idx, self.count), force_mavlink1=force_mavlink1)

class MAVLink_fence_fetch_point_message(MAVLink_message):
        '''
        Request a current fence point from MAV.
        '''
        id = MAVLINK_MSG_ID_FENCE_FETCH_POINT
        name = 'FENCE_FETCH_POINT'
        fieldnames = ['target_system', 'target_component', 'idx']
        ordered_fieldnames = ['target_system', 'target_component', 'idx']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 68
        unpacker = struct.Struct('<BBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, idx):
                MAVLink_message.__init__(self, MAVLink_fence_fetch_point_message.id, MAVLink_fence_fetch_point_message.name)
                self._fieldnames = MAVLink_fence_fetch_point_message.fieldnames
                self._instance_field = MAVLink_fence_fetch_point_message.instance_field
                self._instance_offset = MAVLink_fence_fetch_point_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 68, struct.pack('<BBB', self.target_system, self.target_component, self.idx), force_mavlink1=force_mavlink1)

class MAVLink_ahrs_message(MAVLink_message):
        '''
        Status of DCM attitude estimator.
        '''
        id = MAVLINK_MSG_ID_AHRS
        name = 'AHRS'
        fieldnames = ['omegaIx', 'omegaIy', 'omegaIz', 'accel_weight', 'renorm_val', 'error_rp', 'error_yaw']
        ordered_fieldnames = ['omegaIx', 'omegaIy', 'omegaIz', 'accel_weight', 'renorm_val', 'error_rp', 'error_yaw']
        fieldtypes = ['float', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"omegaIx": "rad/s", "omegaIy": "rad/s", "omegaIz": "rad/s"}
        format = '<fffffff'
        native_format = bytearray('<fffffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 127
        unpacker = struct.Struct('<fffffff')
        instance_field = None
        instance_offset = -1

        def __init__(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw):
                MAVLink_message.__init__(self, MAVLink_ahrs_message.id, MAVLink_ahrs_message.name)
                self._fieldnames = MAVLink_ahrs_message.fieldnames
                self._instance_field = MAVLink_ahrs_message.instance_field
                self._instance_offset = MAVLink_ahrs_message.instance_offset
                self.omegaIx = omegaIx
                self.omegaIy = omegaIy
                self.omegaIz = omegaIz
                self.accel_weight = accel_weight
                self.renorm_val = renorm_val
                self.error_rp = error_rp
                self.error_yaw = error_yaw

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 127, struct.pack('<fffffff', self.omegaIx, self.omegaIy, self.omegaIz, self.accel_weight, self.renorm_val, self.error_rp, self.error_yaw), force_mavlink1=force_mavlink1)

class MAVLink_simstate_message(MAVLink_message):
        '''
        Status of simulation environment, if used.
        '''
        id = MAVLINK_MSG_ID_SIMSTATE
        name = 'SIMSTATE'
        fieldnames = ['roll', 'pitch', 'yaw', 'xacc', 'yacc', 'zacc', 'xgyro', 'ygyro', 'zgyro', 'lat', 'lng']
        ordered_fieldnames = ['roll', 'pitch', 'yaw', 'xacc', 'yacc', 'zacc', 'xgyro', 'ygyro', 'zgyro', 'lat', 'lng']
        fieldtypes = ['float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'int32_t', 'int32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"roll": "rad", "pitch": "rad", "yaw": "rad", "xacc": "m/s/s", "yacc": "m/s/s", "zacc": "m/s/s", "xgyro": "rad/s", "ygyro": "rad/s", "zgyro": "rad/s", "lat": "degE7", "lng": "degE7"}
        format = '<fffffffffii'
        native_format = bytearray('<fffffffffii', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 154
        unpacker = struct.Struct('<fffffffffii')
        instance_field = None
        instance_offset = -1

        def __init__(self, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng):
                MAVLink_message.__init__(self, MAVLink_simstate_message.id, MAVLink_simstate_message.name)
                self._fieldnames = MAVLink_simstate_message.fieldnames
                self._instance_field = MAVLink_simstate_message.instance_field
                self._instance_offset = MAVLink_simstate_message.instance_offset
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.xacc = xacc
                self.yacc = yacc
                self.zacc = zacc
                self.xgyro = xgyro
                self.ygyro = ygyro
                self.zgyro = zgyro
                self.lat = lat
                self.lng = lng

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 154, struct.pack('<fffffffffii', self.roll, self.pitch, self.yaw, self.xacc, self.yacc, self.zacc, self.xgyro, self.ygyro, self.zgyro, self.lat, self.lng), force_mavlink1=force_mavlink1)

class MAVLink_hwstatus_message(MAVLink_message):
        '''
        Status of key hardware.
        '''
        id = MAVLINK_MSG_ID_HWSTATUS
        name = 'HWSTATUS'
        fieldnames = ['Vcc', 'I2Cerr']
        ordered_fieldnames = ['Vcc', 'I2Cerr']
        fieldtypes = ['uint16_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"Vcc": "mV"}
        format = '<HB'
        native_format = bytearray('<HB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 21
        unpacker = struct.Struct('<HB')
        instance_field = None
        instance_offset = -1

        def __init__(self, Vcc, I2Cerr):
                MAVLink_message.__init__(self, MAVLink_hwstatus_message.id, MAVLink_hwstatus_message.name)
                self._fieldnames = MAVLink_hwstatus_message.fieldnames
                self._instance_field = MAVLink_hwstatus_message.instance_field
                self._instance_offset = MAVLink_hwstatus_message.instance_offset
                self.Vcc = Vcc
                self.I2Cerr = I2Cerr

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 21, struct.pack('<HB', self.Vcc, self.I2Cerr), force_mavlink1=force_mavlink1)

class MAVLink_radio_message(MAVLink_message):
        '''
        Status generated by radio.
        '''
        id = MAVLINK_MSG_ID_RADIO
        name = 'RADIO'
        fieldnames = ['rssi', 'remrssi', 'txbuf', 'noise', 'remnoise', 'rxerrors', 'fixed']
        ordered_fieldnames = ['rxerrors', 'fixed', 'rssi', 'remrssi', 'txbuf', 'noise', 'remnoise']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint16_t', 'uint16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"txbuf": "%"}
        format = '<HHBBBBB'
        native_format = bytearray('<HHBBBBB', 'ascii')
        orders = [2, 3, 4, 5, 6, 0, 1]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 21
        unpacker = struct.Struct('<HHBBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed):
                MAVLink_message.__init__(self, MAVLink_radio_message.id, MAVLink_radio_message.name)
                self._fieldnames = MAVLink_radio_message.fieldnames
                self._instance_field = MAVLink_radio_message.instance_field
                self._instance_offset = MAVLink_radio_message.instance_offset
                self.rssi = rssi
                self.remrssi = remrssi
                self.txbuf = txbuf
                self.noise = noise
                self.remnoise = remnoise
                self.rxerrors = rxerrors
                self.fixed = fixed

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 21, struct.pack('<HHBBBBB', self.rxerrors, self.fixed, self.rssi, self.remrssi, self.txbuf, self.noise, self.remnoise), force_mavlink1=force_mavlink1)

class MAVLink_limits_status_message(MAVLink_message):
        '''
        Status of AP_Limits. Sent in extended status stream when
        AP_Limits is enabled.
        '''
        id = MAVLINK_MSG_ID_LIMITS_STATUS
        name = 'LIMITS_STATUS'
        fieldnames = ['limits_state', 'last_trigger', 'last_action', 'last_recovery', 'last_clear', 'breach_count', 'mods_enabled', 'mods_required', 'mods_triggered']
        ordered_fieldnames = ['last_trigger', 'last_action', 'last_recovery', 'last_clear', 'breach_count', 'limits_state', 'mods_enabled', 'mods_required', 'mods_triggered']
        fieldtypes = ['uint8_t', 'uint32_t', 'uint32_t', 'uint32_t', 'uint32_t', 'uint16_t', 'uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {"mods_enabled": "bitmask", "mods_required": "bitmask", "mods_triggered": "bitmask"}
        fieldenums_by_name = {"limits_state": "LIMITS_STATE", "mods_enabled": "LIMIT_MODULE", "mods_required": "LIMIT_MODULE", "mods_triggered": "LIMIT_MODULE"}
        fieldunits_by_name = {"last_trigger": "ms", "last_action": "ms", "last_recovery": "ms", "last_clear": "ms"}
        format = '<IIIIHBBBB'
        native_format = bytearray('<IIIIHBBBB', 'ascii')
        orders = [5, 0, 1, 2, 3, 4, 6, 7, 8]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 144
        unpacker = struct.Struct('<IIIIHBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered):
                MAVLink_message.__init__(self, MAVLink_limits_status_message.id, MAVLink_limits_status_message.name)
                self._fieldnames = MAVLink_limits_status_message.fieldnames
                self._instance_field = MAVLink_limits_status_message.instance_field
                self._instance_offset = MAVLink_limits_status_message.instance_offset
                self.limits_state = limits_state
                self.last_trigger = last_trigger
                self.last_action = last_action
                self.last_recovery = last_recovery
                self.last_clear = last_clear
                self.breach_count = breach_count
                self.mods_enabled = mods_enabled
                self.mods_required = mods_required
                self.mods_triggered = mods_triggered

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 144, struct.pack('<IIIIHBBBB', self.last_trigger, self.last_action, self.last_recovery, self.last_clear, self.breach_count, self.limits_state, self.mods_enabled, self.mods_required, self.mods_triggered), force_mavlink1=force_mavlink1)

class MAVLink_wind_message(MAVLink_message):
        '''
        Wind estimation.
        '''
        id = MAVLINK_MSG_ID_WIND
        name = 'WIND'
        fieldnames = ['direction', 'speed', 'speed_z']
        ordered_fieldnames = ['direction', 'speed', 'speed_z']
        fieldtypes = ['float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"direction": "deg", "speed": "m/s", "speed_z": "m/s"}
        format = '<fff'
        native_format = bytearray('<fff', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 1
        unpacker = struct.Struct('<fff')
        instance_field = None
        instance_offset = -1

        def __init__(self, direction, speed, speed_z):
                MAVLink_message.__init__(self, MAVLink_wind_message.id, MAVLink_wind_message.name)
                self._fieldnames = MAVLink_wind_message.fieldnames
                self._instance_field = MAVLink_wind_message.instance_field
                self._instance_offset = MAVLink_wind_message.instance_offset
                self.direction = direction
                self.speed = speed
                self.speed_z = speed_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 1, struct.pack('<fff', self.direction, self.speed, self.speed_z), force_mavlink1=force_mavlink1)

class MAVLink_data16_message(MAVLink_message):
        '''
        Data packet, size 16.
        '''
        id = MAVLINK_MSG_ID_DATA16
        name = 'DATA16'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB16B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 16]
        array_lengths = [0, 0, 16]
        crc_extra = 234
        unpacker = struct.Struct('<BB16B')
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data16_message.id, MAVLink_data16_message.name)
                self._fieldnames = MAVLink_data16_message.fieldnames
                self._instance_field = MAVLink_data16_message.instance_field
                self._instance_offset = MAVLink_data16_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 234, struct.pack('<BB16B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15]), force_mavlink1=force_mavlink1)

class MAVLink_data32_message(MAVLink_message):
        '''
        Data packet, size 32.
        '''
        id = MAVLINK_MSG_ID_DATA32
        name = 'DATA32'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB32B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 32]
        array_lengths = [0, 0, 32]
        crc_extra = 73
        unpacker = struct.Struct('<BB32B')
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data32_message.id, MAVLink_data32_message.name)
                self._fieldnames = MAVLink_data32_message.fieldnames
                self._instance_field = MAVLink_data32_message.instance_field
                self._instance_offset = MAVLink_data32_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 73, struct.pack('<BB32B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31]), force_mavlink1=force_mavlink1)

class MAVLink_data64_message(MAVLink_message):
        '''
        Data packet, size 64.
        '''
        id = MAVLINK_MSG_ID_DATA64
        name = 'DATA64'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB64B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 64]
        array_lengths = [0, 0, 64]
        crc_extra = 181
        unpacker = struct.Struct('<BB64B')
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data64_message.id, MAVLink_data64_message.name)
                self._fieldnames = MAVLink_data64_message.fieldnames
                self._instance_field = MAVLink_data64_message.instance_field
                self._instance_offset = MAVLink_data64_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 181, struct.pack('<BB64B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31], self.data[32], self.data[33], self.data[34], self.data[35], self.data[36], self.data[37], self.data[38], self.data[39], self.data[40], self.data[41], self.data[42], self.data[43], self.data[44], self.data[45], self.data[46], self.data[47], self.data[48], self.data[49], self.data[50], self.data[51], self.data[52], self.data[53], self.data[54], self.data[55], self.data[56], self.data[57], self.data[58], self.data[59], self.data[60], self.data[61], self.data[62], self.data[63]), force_mavlink1=force_mavlink1)

class MAVLink_data96_message(MAVLink_message):
        '''
        Data packet, size 96.
        '''
        id = MAVLINK_MSG_ID_DATA96
        name = 'DATA96'
        fieldnames = ['type', 'len', 'data']
        ordered_fieldnames = ['type', 'len', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"len": "bytes"}
        format = '<BB96B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 96]
        array_lengths = [0, 0, 96]
        crc_extra = 22
        unpacker = struct.Struct('<BB96B')
        instance_field = None
        instance_offset = -1

        def __init__(self, type, len, data):
                MAVLink_message.__init__(self, MAVLink_data96_message.id, MAVLink_data96_message.name)
                self._fieldnames = MAVLink_data96_message.fieldnames
                self._instance_field = MAVLink_data96_message.instance_field
                self._instance_offset = MAVLink_data96_message.instance_offset
                self.type = type
                self.len = len
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 22, struct.pack('<BB96B', self.type, self.len, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31], self.data[32], self.data[33], self.data[34], self.data[35], self.data[36], self.data[37], self.data[38], self.data[39], self.data[40], self.data[41], self.data[42], self.data[43], self.data[44], self.data[45], self.data[46], self.data[47], self.data[48], self.data[49], self.data[50], self.data[51], self.data[52], self.data[53], self.data[54], self.data[55], self.data[56], self.data[57], self.data[58], self.data[59], self.data[60], self.data[61], self.data[62], self.data[63], self.data[64], self.data[65], self.data[66], self.data[67], self.data[68], self.data[69], self.data[70], self.data[71], self.data[72], self.data[73], self.data[74], self.data[75], self.data[76], self.data[77], self.data[78], self.data[79], self.data[80], self.data[81], self.data[82], self.data[83], self.data[84], self.data[85], self.data[86], self.data[87], self.data[88], self.data[89], self.data[90], self.data[91], self.data[92], self.data[93], self.data[94], self.data[95]), force_mavlink1=force_mavlink1)

class MAVLink_rangefinder_message(MAVLink_message):
        '''
        Rangefinder reporting.
        '''
        id = MAVLINK_MSG_ID_RANGEFINDER
        name = 'RANGEFINDER'
        fieldnames = ['distance', 'voltage']
        ordered_fieldnames = ['distance', 'voltage']
        fieldtypes = ['float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"distance": "m", "voltage": "V"}
        format = '<ff'
        native_format = bytearray('<ff', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 83
        unpacker = struct.Struct('<ff')
        instance_field = None
        instance_offset = -1

        def __init__(self, distance, voltage):
                MAVLink_message.__init__(self, MAVLink_rangefinder_message.id, MAVLink_rangefinder_message.name)
                self._fieldnames = MAVLink_rangefinder_message.fieldnames
                self._instance_field = MAVLink_rangefinder_message.instance_field
                self._instance_offset = MAVLink_rangefinder_message.instance_offset
                self.distance = distance
                self.voltage = voltage

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 83, struct.pack('<ff', self.distance, self.voltage), force_mavlink1=force_mavlink1)

class MAVLink_airspeed_autocal_message(MAVLink_message):
        '''
        Airspeed auto-calibration.
        '''
        id = MAVLINK_MSG_ID_AIRSPEED_AUTOCAL
        name = 'AIRSPEED_AUTOCAL'
        fieldnames = ['vx', 'vy', 'vz', 'diff_pressure', 'EAS2TAS', 'ratio', 'state_x', 'state_y', 'state_z', 'Pax', 'Pby', 'Pcz']
        ordered_fieldnames = ['vx', 'vy', 'vz', 'diff_pressure', 'EAS2TAS', 'ratio', 'state_x', 'state_y', 'state_z', 'Pax', 'Pby', 'Pcz']
        fieldtypes = ['float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"vx": "m/s", "vy": "m/s", "vz": "m/s", "diff_pressure": "Pa"}
        format = '<ffffffffffff'
        native_format = bytearray('<ffffffffffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 167
        unpacker = struct.Struct('<ffffffffffff')
        instance_field = None
        instance_offset = -1

        def __init__(self, vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz):
                MAVLink_message.__init__(self, MAVLink_airspeed_autocal_message.id, MAVLink_airspeed_autocal_message.name)
                self._fieldnames = MAVLink_airspeed_autocal_message.fieldnames
                self._instance_field = MAVLink_airspeed_autocal_message.instance_field
                self._instance_offset = MAVLink_airspeed_autocal_message.instance_offset
                self.vx = vx
                self.vy = vy
                self.vz = vz
                self.diff_pressure = diff_pressure
                self.EAS2TAS = EAS2TAS
                self.ratio = ratio
                self.state_x = state_x
                self.state_y = state_y
                self.state_z = state_z
                self.Pax = Pax
                self.Pby = Pby
                self.Pcz = Pcz

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 167, struct.pack('<ffffffffffff', self.vx, self.vy, self.vz, self.diff_pressure, self.EAS2TAS, self.ratio, self.state_x, self.state_y, self.state_z, self.Pax, self.Pby, self.Pcz), force_mavlink1=force_mavlink1)

class MAVLink_rally_point_message(MAVLink_message):
        '''
        A rally point. Used to set a point when from GCS -> MAV. Also
        used to return a point from MAV -> GCS.
        '''
        id = MAVLINK_MSG_ID_RALLY_POINT
        name = 'RALLY_POINT'
        fieldnames = ['target_system', 'target_component', 'idx', 'count', 'lat', 'lng', 'alt', 'break_alt', 'land_dir', 'flags']
        ordered_fieldnames = ['lat', 'lng', 'alt', 'break_alt', 'land_dir', 'target_system', 'target_component', 'idx', 'count', 'flags']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'int32_t', 'int32_t', 'int16_t', 'int16_t', 'uint16_t', 'uint8_t']
        fielddisplays_by_name = {"flags": "bitmask"}
        fieldenums_by_name = {"flags": "RALLY_FLAGS"}
        fieldunits_by_name = {"lat": "degE7", "lng": "degE7", "alt": "m", "break_alt": "m", "land_dir": "cdeg"}
        format = '<iihhHBBBBB'
        native_format = bytearray('<iihhHBBBBB', 'ascii')
        orders = [5, 6, 7, 8, 0, 1, 2, 3, 4, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 138
        unpacker = struct.Struct('<iihhHBBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags):
                MAVLink_message.__init__(self, MAVLink_rally_point_message.id, MAVLink_rally_point_message.name)
                self._fieldnames = MAVLink_rally_point_message.fieldnames
                self._instance_field = MAVLink_rally_point_message.instance_field
                self._instance_offset = MAVLink_rally_point_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx
                self.count = count
                self.lat = lat
                self.lng = lng
                self.alt = alt
                self.break_alt = break_alt
                self.land_dir = land_dir
                self.flags = flags

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 138, struct.pack('<iihhHBBBBB', self.lat, self.lng, self.alt, self.break_alt, self.land_dir, self.target_system, self.target_component, self.idx, self.count, self.flags), force_mavlink1=force_mavlink1)

class MAVLink_rally_fetch_point_message(MAVLink_message):
        '''
        Request a current rally point from MAV. MAV should respond
        with a RALLY_POINT message. MAV should not respond if the
        request is invalid.
        '''
        id = MAVLINK_MSG_ID_RALLY_FETCH_POINT
        name = 'RALLY_FETCH_POINT'
        fieldnames = ['target_system', 'target_component', 'idx']
        ordered_fieldnames = ['target_system', 'target_component', 'idx']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 234
        unpacker = struct.Struct('<BBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, idx):
                MAVLink_message.__init__(self, MAVLink_rally_fetch_point_message.id, MAVLink_rally_fetch_point_message.name)
                self._fieldnames = MAVLink_rally_fetch_point_message.fieldnames
                self._instance_field = MAVLink_rally_fetch_point_message.instance_field
                self._instance_offset = MAVLink_rally_fetch_point_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.idx = idx

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 234, struct.pack('<BBB', self.target_system, self.target_component, self.idx), force_mavlink1=force_mavlink1)

class MAVLink_compassmot_status_message(MAVLink_message):
        '''
        Status of compassmot calibration.
        '''
        id = MAVLINK_MSG_ID_COMPASSMOT_STATUS
        name = 'COMPASSMOT_STATUS'
        fieldnames = ['throttle', 'current', 'interference', 'CompensationX', 'CompensationY', 'CompensationZ']
        ordered_fieldnames = ['current', 'CompensationX', 'CompensationY', 'CompensationZ', 'throttle', 'interference']
        fieldtypes = ['uint16_t', 'float', 'uint16_t', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"throttle": "d%", "current": "A", "interference": "%"}
        format = '<ffffHH'
        native_format = bytearray('<ffffHH', 'ascii')
        orders = [4, 0, 5, 1, 2, 3]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 240
        unpacker = struct.Struct('<ffffHH')
        instance_field = None
        instance_offset = -1

        def __init__(self, throttle, current, interference, CompensationX, CompensationY, CompensationZ):
                MAVLink_message.__init__(self, MAVLink_compassmot_status_message.id, MAVLink_compassmot_status_message.name)
                self._fieldnames = MAVLink_compassmot_status_message.fieldnames
                self._instance_field = MAVLink_compassmot_status_message.instance_field
                self._instance_offset = MAVLink_compassmot_status_message.instance_offset
                self.throttle = throttle
                self.current = current
                self.interference = interference
                self.CompensationX = CompensationX
                self.CompensationY = CompensationY
                self.CompensationZ = CompensationZ

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 240, struct.pack('<ffffHH', self.current, self.CompensationX, self.CompensationY, self.CompensationZ, self.throttle, self.interference), force_mavlink1=force_mavlink1)

class MAVLink_ahrs2_message(MAVLink_message):
        '''
        Status of secondary AHRS filter if available.
        '''
        id = MAVLINK_MSG_ID_AHRS2
        name = 'AHRS2'
        fieldnames = ['roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng']
        ordered_fieldnames = ['roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng']
        fieldtypes = ['float', 'float', 'float', 'float', 'int32_t', 'int32_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"roll": "rad", "pitch": "rad", "yaw": "rad", "altitude": "m", "lat": "degE7", "lng": "degE7"}
        format = '<ffffii'
        native_format = bytearray('<ffffii', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 47
        unpacker = struct.Struct('<ffffii')
        instance_field = None
        instance_offset = -1

        def __init__(self, roll, pitch, yaw, altitude, lat, lng):
                MAVLink_message.__init__(self, MAVLink_ahrs2_message.id, MAVLink_ahrs2_message.name)
                self._fieldnames = MAVLink_ahrs2_message.fieldnames
                self._instance_field = MAVLink_ahrs2_message.instance_field
                self._instance_offset = MAVLink_ahrs2_message.instance_offset
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.altitude = altitude
                self.lat = lat
                self.lng = lng

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 47, struct.pack('<ffffii', self.roll, self.pitch, self.yaw, self.altitude, self.lat, self.lng), force_mavlink1=force_mavlink1)

class MAVLink_camera_status_message(MAVLink_message):
        '''
        Camera Event.
        '''
        id = MAVLINK_MSG_ID_CAMERA_STATUS
        name = 'CAMERA_STATUS'
        fieldnames = ['time_usec', 'target_system', 'cam_idx', 'img_idx', 'event_id', 'p1', 'p2', 'p3', 'p4']
        ordered_fieldnames = ['time_usec', 'p1', 'p2', 'p3', 'p4', 'img_idx', 'target_system', 'cam_idx', 'event_id']
        fieldtypes = ['uint64_t', 'uint8_t', 'uint8_t', 'uint16_t', 'uint8_t', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"event_id": "CAMERA_STATUS_TYPES"}
        fieldunits_by_name = {"time_usec": "us"}
        format = '<QffffHBBB'
        native_format = bytearray('<QffffHBBB', 'ascii')
        orders = [0, 6, 7, 5, 8, 1, 2, 3, 4]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 189
        unpacker = struct.Struct('<QffffHBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4):
                MAVLink_message.__init__(self, MAVLink_camera_status_message.id, MAVLink_camera_status_message.name)
                self._fieldnames = MAVLink_camera_status_message.fieldnames
                self._instance_field = MAVLink_camera_status_message.instance_field
                self._instance_offset = MAVLink_camera_status_message.instance_offset
                self.time_usec = time_usec
                self.target_system = target_system
                self.cam_idx = cam_idx
                self.img_idx = img_idx
                self.event_id = event_id
                self.p1 = p1
                self.p2 = p2
                self.p3 = p3
                self.p4 = p4

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 189, struct.pack('<QffffHBBB', self.time_usec, self.p1, self.p2, self.p3, self.p4, self.img_idx, self.target_system, self.cam_idx, self.event_id), force_mavlink1=force_mavlink1)

class MAVLink_camera_feedback_message(MAVLink_message):
        '''
        Camera Capture Feedback.
        '''
        id = MAVLINK_MSG_ID_CAMERA_FEEDBACK
        name = 'CAMERA_FEEDBACK'
        fieldnames = ['time_usec', 'target_system', 'cam_idx', 'img_idx', 'lat', 'lng', 'alt_msl', 'alt_rel', 'roll', 'pitch', 'yaw', 'foc_len', 'flags']
        ordered_fieldnames = ['time_usec', 'lat', 'lng', 'alt_msl', 'alt_rel', 'roll', 'pitch', 'yaw', 'foc_len', 'img_idx', 'target_system', 'cam_idx', 'flags']
        fieldtypes = ['uint64_t', 'uint8_t', 'uint8_t', 'uint16_t', 'int32_t', 'int32_t', 'float', 'float', 'float', 'float', 'float', 'float', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"flags": "CAMERA_FEEDBACK_FLAGS"}
        fieldunits_by_name = {"time_usec": "us", "lat": "degE7", "lng": "degE7", "alt_msl": "m", "alt_rel": "m", "roll": "deg", "pitch": "deg", "yaw": "deg", "foc_len": "mm"}
        format = '<QiiffffffHBBB'
        native_format = bytearray('<QiiffffffHBBB', 'ascii')
        orders = [0, 10, 11, 9, 1, 2, 3, 4, 5, 6, 7, 8, 12]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 52
        unpacker = struct.Struct('<QiiffffffHBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags):
                MAVLink_message.__init__(self, MAVLink_camera_feedback_message.id, MAVLink_camera_feedback_message.name)
                self._fieldnames = MAVLink_camera_feedback_message.fieldnames
                self._instance_field = MAVLink_camera_feedback_message.instance_field
                self._instance_offset = MAVLink_camera_feedback_message.instance_offset
                self.time_usec = time_usec
                self.target_system = target_system
                self.cam_idx = cam_idx
                self.img_idx = img_idx
                self.lat = lat
                self.lng = lng
                self.alt_msl = alt_msl
                self.alt_rel = alt_rel
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.foc_len = foc_len
                self.flags = flags

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 52, struct.pack('<QiiffffffHBBB', self.time_usec, self.lat, self.lng, self.alt_msl, self.alt_rel, self.roll, self.pitch, self.yaw, self.foc_len, self.img_idx, self.target_system, self.cam_idx, self.flags), force_mavlink1=force_mavlink1)

class MAVLink_battery2_message(MAVLink_message):
        '''
        2nd Battery status
        '''
        id = MAVLINK_MSG_ID_BATTERY2
        name = 'BATTERY2'
        fieldnames = ['voltage', 'current_battery']
        ordered_fieldnames = ['voltage', 'current_battery']
        fieldtypes = ['uint16_t', 'int16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"voltage": "mV", "current_battery": "cA"}
        format = '<Hh'
        native_format = bytearray('<Hh', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 174
        unpacker = struct.Struct('<Hh')
        instance_field = None
        instance_offset = -1

        def __init__(self, voltage, current_battery):
                MAVLink_message.__init__(self, MAVLink_battery2_message.id, MAVLink_battery2_message.name)
                self._fieldnames = MAVLink_battery2_message.fieldnames
                self._instance_field = MAVLink_battery2_message.instance_field
                self._instance_offset = MAVLink_battery2_message.instance_offset
                self.voltage = voltage
                self.current_battery = current_battery

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 174, struct.pack('<Hh', self.voltage, self.current_battery), force_mavlink1=force_mavlink1)

class MAVLink_ahrs3_message(MAVLink_message):
        '''
        Status of third AHRS filter if available. This is for ANU
        research group (Ali and Sean).
        '''
        id = MAVLINK_MSG_ID_AHRS3
        name = 'AHRS3'
        fieldnames = ['roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng', 'v1', 'v2', 'v3', 'v4']
        ordered_fieldnames = ['roll', 'pitch', 'yaw', 'altitude', 'lat', 'lng', 'v1', 'v2', 'v3', 'v4']
        fieldtypes = ['float', 'float', 'float', 'float', 'int32_t', 'int32_t', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"roll": "rad", "pitch": "rad", "yaw": "rad", "altitude": "m", "lat": "degE7", "lng": "degE7"}
        format = '<ffffiiffff'
        native_format = bytearray('<ffffiiffff', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 229
        unpacker = struct.Struct('<ffffiiffff')
        instance_field = None
        instance_offset = -1

        def __init__(self, roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4):
                MAVLink_message.__init__(self, MAVLink_ahrs3_message.id, MAVLink_ahrs3_message.name)
                self._fieldnames = MAVLink_ahrs3_message.fieldnames
                self._instance_field = MAVLink_ahrs3_message.instance_field
                self._instance_offset = MAVLink_ahrs3_message.instance_offset
                self.roll = roll
                self.pitch = pitch
                self.yaw = yaw
                self.altitude = altitude
                self.lat = lat
                self.lng = lng
                self.v1 = v1
                self.v2 = v2
                self.v3 = v3
                self.v4 = v4

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 229, struct.pack('<ffffiiffff', self.roll, self.pitch, self.yaw, self.altitude, self.lat, self.lng, self.v1, self.v2, self.v3, self.v4), force_mavlink1=force_mavlink1)

class MAVLink_autopilot_version_request_message(MAVLink_message):
        '''
        Request the autopilot version from the system/component.
        '''
        id = MAVLINK_MSG_ID_AUTOPILOT_VERSION_REQUEST
        name = 'AUTOPILOT_VERSION_REQUEST'
        fieldnames = ['target_system', 'target_component']
        ordered_fieldnames = ['target_system', 'target_component']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 85
        unpacker = struct.Struct('<BB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component):
                MAVLink_message.__init__(self, MAVLink_autopilot_version_request_message.id, MAVLink_autopilot_version_request_message.name)
                self._fieldnames = MAVLink_autopilot_version_request_message.fieldnames
                self._instance_field = MAVLink_autopilot_version_request_message.instance_field
                self._instance_offset = MAVLink_autopilot_version_request_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 85, struct.pack('<BB', self.target_system, self.target_component), force_mavlink1=force_mavlink1)

class MAVLink_remote_log_data_block_message(MAVLink_message):
        '''
        Send a block of log data to remote location.
        '''
        id = MAVLINK_MSG_ID_REMOTE_LOG_DATA_BLOCK
        name = 'REMOTE_LOG_DATA_BLOCK'
        fieldnames = ['target_system', 'target_component', 'seqno', 'data']
        ordered_fieldnames = ['seqno', 'target_system', 'target_component', 'data']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint32_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"seqno": "MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS"}
        fieldunits_by_name = {}
        format = '<IBB200B'
        native_format = bytearray('<IBBB', 'ascii')
        orders = [1, 2, 0, 3]
        lengths = [1, 1, 1, 200]
        array_lengths = [0, 0, 0, 200]
        crc_extra = 159
        unpacker = struct.Struct('<IBB200B')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, seqno, data):
                MAVLink_message.__init__(self, MAVLink_remote_log_data_block_message.id, MAVLink_remote_log_data_block_message.name)
                self._fieldnames = MAVLink_remote_log_data_block_message.fieldnames
                self._instance_field = MAVLink_remote_log_data_block_message.instance_field
                self._instance_offset = MAVLink_remote_log_data_block_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.seqno = seqno
                self.data = data

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 159, struct.pack('<IBB200B', self.seqno, self.target_system, self.target_component, self.data[0], self.data[1], self.data[2], self.data[3], self.data[4], self.data[5], self.data[6], self.data[7], self.data[8], self.data[9], self.data[10], self.data[11], self.data[12], self.data[13], self.data[14], self.data[15], self.data[16], self.data[17], self.data[18], self.data[19], self.data[20], self.data[21], self.data[22], self.data[23], self.data[24], self.data[25], self.data[26], self.data[27], self.data[28], self.data[29], self.data[30], self.data[31], self.data[32], self.data[33], self.data[34], self.data[35], self.data[36], self.data[37], self.data[38], self.data[39], self.data[40], self.data[41], self.data[42], self.data[43], self.data[44], self.data[45], self.data[46], self.data[47], self.data[48], self.data[49], self.data[50], self.data[51], self.data[52], self.data[53], self.data[54], self.data[55], self.data[56], self.data[57], self.data[58], self.data[59], self.data[60], self.data[61], self.data[62], self.data[63], self.data[64], self.data[65], self.data[66], self.data[67], self.data[68], self.data[69], self.data[70], self.data[71], self.data[72], self.data[73], self.data[74], self.data[75], self.data[76], self.data[77], self.data[78], self.data[79], self.data[80], self.data[81], self.data[82], self.data[83], self.data[84], self.data[85], self.data[86], self.data[87], self.data[88], self.data[89], self.data[90], self.data[91], self.data[92], self.data[93], self.data[94], self.data[95], self.data[96], self.data[97], self.data[98], self.data[99], self.data[100], self.data[101], self.data[102], self.data[103], self.data[104], self.data[105], self.data[106], self.data[107], self.data[108], self.data[109], self.data[110], self.data[111], self.data[112], self.data[113], self.data[114], self.data[115], self.data[116], self.data[117], self.data[118], self.data[119], self.data[120], self.data[121], self.data[122], self.data[123], self.data[124], self.data[125], self.data[126], self.data[127], self.data[128], self.data[129], self.data[130], self.data[131], self.data[132], self.data[133], self.data[134], self.data[135], self.data[136], self.data[137], self.data[138], self.data[139], self.data[140], self.data[141], self.data[142], self.data[143], self.data[144], self.data[145], self.data[146], self.data[147], self.data[148], self.data[149], self.data[150], self.data[151], self.data[152], self.data[153], self.data[154], self.data[155], self.data[156], self.data[157], self.data[158], self.data[159], self.data[160], self.data[161], self.data[162], self.data[163], self.data[164], self.data[165], self.data[166], self.data[167], self.data[168], self.data[169], self.data[170], self.data[171], self.data[172], self.data[173], self.data[174], self.data[175], self.data[176], self.data[177], self.data[178], self.data[179], self.data[180], self.data[181], self.data[182], self.data[183], self.data[184], self.data[185], self.data[186], self.data[187], self.data[188], self.data[189], self.data[190], self.data[191], self.data[192], self.data[193], self.data[194], self.data[195], self.data[196], self.data[197], self.data[198], self.data[199]), force_mavlink1=force_mavlink1)

class MAVLink_remote_log_block_status_message(MAVLink_message):
        '''
        Send Status of each log block that autopilot board might have
        sent.
        '''
        id = MAVLINK_MSG_ID_REMOTE_LOG_BLOCK_STATUS
        name = 'REMOTE_LOG_BLOCK_STATUS'
        fieldnames = ['target_system', 'target_component', 'seqno', 'status']
        ordered_fieldnames = ['seqno', 'target_system', 'target_component', 'status']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint32_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"status": "MAV_REMOTE_LOG_DATA_BLOCK_STATUSES"}
        fieldunits_by_name = {}
        format = '<IBBB'
        native_format = bytearray('<IBBB', 'ascii')
        orders = [1, 2, 0, 3]
        lengths = [1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0]
        crc_extra = 186
        unpacker = struct.Struct('<IBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, seqno, status):
                MAVLink_message.__init__(self, MAVLink_remote_log_block_status_message.id, MAVLink_remote_log_block_status_message.name)
                self._fieldnames = MAVLink_remote_log_block_status_message.fieldnames
                self._instance_field = MAVLink_remote_log_block_status_message.instance_field
                self._instance_offset = MAVLink_remote_log_block_status_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.seqno = seqno
                self.status = status

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 186, struct.pack('<IBBB', self.seqno, self.target_system, self.target_component, self.status), force_mavlink1=force_mavlink1)

class MAVLink_led_control_message(MAVLink_message):
        '''
        Control vehicle LEDs.
        '''
        id = MAVLINK_MSG_ID_LED_CONTROL
        name = 'LED_CONTROL'
        fieldnames = ['target_system', 'target_component', 'instance', 'pattern', 'custom_len', 'custom_bytes']
        ordered_fieldnames = ['target_system', 'target_component', 'instance', 'pattern', 'custom_len', 'custom_bytes']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<BBBBB24B'
        native_format = bytearray('<BBBBBB', 'ascii')
        orders = [0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 24]
        array_lengths = [0, 0, 0, 0, 0, 24]
        crc_extra = 72
        unpacker = struct.Struct('<BBBBB24B')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, instance, pattern, custom_len, custom_bytes):
                MAVLink_message.__init__(self, MAVLink_led_control_message.id, MAVLink_led_control_message.name)
                self._fieldnames = MAVLink_led_control_message.fieldnames
                self._instance_field = MAVLink_led_control_message.instance_field
                self._instance_offset = MAVLink_led_control_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.instance = instance
                self.pattern = pattern
                self.custom_len = custom_len
                self.custom_bytes = custom_bytes

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 72, struct.pack('<BBBBB24B', self.target_system, self.target_component, self.instance, self.pattern, self.custom_len, self.custom_bytes[0], self.custom_bytes[1], self.custom_bytes[2], self.custom_bytes[3], self.custom_bytes[4], self.custom_bytes[5], self.custom_bytes[6], self.custom_bytes[7], self.custom_bytes[8], self.custom_bytes[9], self.custom_bytes[10], self.custom_bytes[11], self.custom_bytes[12], self.custom_bytes[13], self.custom_bytes[14], self.custom_bytes[15], self.custom_bytes[16], self.custom_bytes[17], self.custom_bytes[18], self.custom_bytes[19], self.custom_bytes[20], self.custom_bytes[21], self.custom_bytes[22], self.custom_bytes[23]), force_mavlink1=force_mavlink1)

class MAVLink_mag_cal_progress_message(MAVLink_message):
        '''
        Reports progress of compass calibration.
        '''
        id = MAVLINK_MSG_ID_MAG_CAL_PROGRESS
        name = 'MAG_CAL_PROGRESS'
        fieldnames = ['compass_id', 'cal_mask', 'cal_status', 'attempt', 'completion_pct', 'completion_mask', 'direction_x', 'direction_y', 'direction_z']
        ordered_fieldnames = ['direction_x', 'direction_y', 'direction_z', 'compass_id', 'cal_mask', 'cal_status', 'attempt', 'completion_pct', 'completion_mask']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'float', 'float', 'float']
        fielddisplays_by_name = {"cal_mask": "bitmask"}
        fieldenums_by_name = {"cal_status": "MAG_CAL_STATUS"}
        fieldunits_by_name = {"completion_pct": "%"}
        format = '<fffBBBBB10B'
        native_format = bytearray('<fffBBBBBB', 'ascii')
        orders = [3, 4, 5, 6, 7, 8, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 10]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 10]
        crc_extra = 92
        unpacker = struct.Struct('<fffBBBBB10B')
        instance_field = None
        instance_offset = -1

        def __init__(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z):
                MAVLink_message.__init__(self, MAVLink_mag_cal_progress_message.id, MAVLink_mag_cal_progress_message.name)
                self._fieldnames = MAVLink_mag_cal_progress_message.fieldnames
                self._instance_field = MAVLink_mag_cal_progress_message.instance_field
                self._instance_offset = MAVLink_mag_cal_progress_message.instance_offset
                self.compass_id = compass_id
                self.cal_mask = cal_mask
                self.cal_status = cal_status
                self.attempt = attempt
                self.completion_pct = completion_pct
                self.completion_mask = completion_mask
                self.direction_x = direction_x
                self.direction_y = direction_y
                self.direction_z = direction_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 92, struct.pack('<fffBBBBB10B', self.direction_x, self.direction_y, self.direction_z, self.compass_id, self.cal_mask, self.cal_status, self.attempt, self.completion_pct, self.completion_mask[0], self.completion_mask[1], self.completion_mask[2], self.completion_mask[3], self.completion_mask[4], self.completion_mask[5], self.completion_mask[6], self.completion_mask[7], self.completion_mask[8], self.completion_mask[9]), force_mavlink1=force_mavlink1)

class MAVLink_mag_cal_report_message(MAVLink_message):
        '''
        Reports results of completed compass calibration. Sent until
        MAG_CAL_ACK received.
        '''
        id = MAVLINK_MSG_ID_MAG_CAL_REPORT
        name = 'MAG_CAL_REPORT'
        fieldnames = ['compass_id', 'cal_mask', 'cal_status', 'autosaved', 'fitness', 'ofs_x', 'ofs_y', 'ofs_z', 'diag_x', 'diag_y', 'diag_z', 'offdiag_x', 'offdiag_y', 'offdiag_z']
        ordered_fieldnames = ['fitness', 'ofs_x', 'ofs_y', 'ofs_z', 'diag_x', 'diag_y', 'diag_z', 'offdiag_x', 'offdiag_y', 'offdiag_z', 'compass_id', 'cal_mask', 'cal_status', 'autosaved']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {"cal_mask": "bitmask"}
        fieldenums_by_name = {"cal_status": "MAG_CAL_STATUS"}
        fieldunits_by_name = {"fitness": "mgauss"}
        format = '<ffffffffffBBBB'
        native_format = bytearray('<ffffffffffBBBB', 'ascii')
        orders = [10, 11, 12, 13, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 36
        unpacker = struct.Struct('<ffffffffffBBBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z):
                MAVLink_message.__init__(self, MAVLink_mag_cal_report_message.id, MAVLink_mag_cal_report_message.name)
                self._fieldnames = MAVLink_mag_cal_report_message.fieldnames
                self._instance_field = MAVLink_mag_cal_report_message.instance_field
                self._instance_offset = MAVLink_mag_cal_report_message.instance_offset
                self.compass_id = compass_id
                self.cal_mask = cal_mask
                self.cal_status = cal_status
                self.autosaved = autosaved
                self.fitness = fitness
                self.ofs_x = ofs_x
                self.ofs_y = ofs_y
                self.ofs_z = ofs_z
                self.diag_x = diag_x
                self.diag_y = diag_y
                self.diag_z = diag_z
                self.offdiag_x = offdiag_x
                self.offdiag_y = offdiag_y
                self.offdiag_z = offdiag_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 36, struct.pack('<ffffffffffBBBB', self.fitness, self.ofs_x, self.ofs_y, self.ofs_z, self.diag_x, self.diag_y, self.diag_z, self.offdiag_x, self.offdiag_y, self.offdiag_z, self.compass_id, self.cal_mask, self.cal_status, self.autosaved), force_mavlink1=force_mavlink1)

class MAVLink_ekf_status_report_message(MAVLink_message):
        '''
        EKF Status message including flags and variances.
        '''
        id = MAVLINK_MSG_ID_EKF_STATUS_REPORT
        name = 'EKF_STATUS_REPORT'
        fieldnames = ['flags', 'velocity_variance', 'pos_horiz_variance', 'pos_vert_variance', 'compass_variance', 'terrain_alt_variance']
        ordered_fieldnames = ['velocity_variance', 'pos_horiz_variance', 'pos_vert_variance', 'compass_variance', 'terrain_alt_variance', 'flags']
        fieldtypes = ['uint16_t', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {"flags": "bitmask"}
        fieldenums_by_name = {"flags": "EKF_STATUS_FLAGS"}
        fieldunits_by_name = {}
        format = '<fffffH'
        native_format = bytearray('<fffffH', 'ascii')
        orders = [5, 0, 1, 2, 3, 4]
        lengths = [1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0]
        crc_extra = 71
        unpacker = struct.Struct('<fffffH')
        instance_field = None
        instance_offset = -1

        def __init__(self, flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance):
                MAVLink_message.__init__(self, MAVLink_ekf_status_report_message.id, MAVLink_ekf_status_report_message.name)
                self._fieldnames = MAVLink_ekf_status_report_message.fieldnames
                self._instance_field = MAVLink_ekf_status_report_message.instance_field
                self._instance_offset = MAVLink_ekf_status_report_message.instance_offset
                self.flags = flags
                self.velocity_variance = velocity_variance
                self.pos_horiz_variance = pos_horiz_variance
                self.pos_vert_variance = pos_vert_variance
                self.compass_variance = compass_variance
                self.terrain_alt_variance = terrain_alt_variance

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 71, struct.pack('<fffffH', self.velocity_variance, self.pos_horiz_variance, self.pos_vert_variance, self.compass_variance, self.terrain_alt_variance, self.flags), force_mavlink1=force_mavlink1)

class MAVLink_pid_tuning_message(MAVLink_message):
        '''
        PID tuning information.
        '''
        id = MAVLINK_MSG_ID_PID_TUNING
        name = 'PID_TUNING'
        fieldnames = ['axis', 'desired', 'achieved', 'FF', 'P', 'I', 'D']
        ordered_fieldnames = ['desired', 'achieved', 'FF', 'P', 'I', 'D', 'axis']
        fieldtypes = ['uint8_t', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"axis": "PID_TUNING_AXIS"}
        fieldunits_by_name = {"desired": "deg/s", "achieved": "deg/s"}
        format = '<ffffffB'
        native_format = bytearray('<ffffffB', 'ascii')
        orders = [6, 0, 1, 2, 3, 4, 5]
        lengths = [1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0]
        crc_extra = 98
        unpacker = struct.Struct('<ffffffB')
        instance_field = None
        instance_offset = -1

        def __init__(self, axis, desired, achieved, FF, P, I, D):
                MAVLink_message.__init__(self, MAVLink_pid_tuning_message.id, MAVLink_pid_tuning_message.name)
                self._fieldnames = MAVLink_pid_tuning_message.fieldnames
                self._instance_field = MAVLink_pid_tuning_message.instance_field
                self._instance_offset = MAVLink_pid_tuning_message.instance_offset
                self.axis = axis
                self.desired = desired
                self.achieved = achieved
                self.FF = FF
                self.P = P
                self.I = I
                self.D = D

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 98, struct.pack('<ffffffB', self.desired, self.achieved, self.FF, self.P, self.I, self.D, self.axis), force_mavlink1=force_mavlink1)

class MAVLink_deepstall_message(MAVLink_message):
        '''
        Deepstall path planning.
        '''
        id = MAVLINK_MSG_ID_DEEPSTALL
        name = 'DEEPSTALL'
        fieldnames = ['landing_lat', 'landing_lon', 'path_lat', 'path_lon', 'arc_entry_lat', 'arc_entry_lon', 'altitude', 'expected_travel_distance', 'cross_track_error', 'stage']
        ordered_fieldnames = ['landing_lat', 'landing_lon', 'path_lat', 'path_lon', 'arc_entry_lat', 'arc_entry_lon', 'altitude', 'expected_travel_distance', 'cross_track_error', 'stage']
        fieldtypes = ['int32_t', 'int32_t', 'int32_t', 'int32_t', 'int32_t', 'int32_t', 'float', 'float', 'float', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"stage": "DEEPSTALL_STAGE"}
        fieldunits_by_name = {"landing_lat": "degE7", "landing_lon": "degE7", "path_lat": "degE7", "path_lon": "degE7", "arc_entry_lat": "degE7", "arc_entry_lon": "degE7", "altitude": "m", "expected_travel_distance": "m", "cross_track_error": "m"}
        format = '<iiiiiifffB'
        native_format = bytearray('<iiiiiifffB', 'ascii')
        orders = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 120
        unpacker = struct.Struct('<iiiiiifffB')
        instance_field = None
        instance_offset = -1

        def __init__(self, landing_lat, landing_lon, path_lat, path_lon, arc_entry_lat, arc_entry_lon, altitude, expected_travel_distance, cross_track_error, stage):
                MAVLink_message.__init__(self, MAVLink_deepstall_message.id, MAVLink_deepstall_message.name)
                self._fieldnames = MAVLink_deepstall_message.fieldnames
                self._instance_field = MAVLink_deepstall_message.instance_field
                self._instance_offset = MAVLink_deepstall_message.instance_offset
                self.landing_lat = landing_lat
                self.landing_lon = landing_lon
                self.path_lat = path_lat
                self.path_lon = path_lon
                self.arc_entry_lat = arc_entry_lat
                self.arc_entry_lon = arc_entry_lon
                self.altitude = altitude
                self.expected_travel_distance = expected_travel_distance
                self.cross_track_error = cross_track_error
                self.stage = stage

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 120, struct.pack('<iiiiiifffB', self.landing_lat, self.landing_lon, self.path_lat, self.path_lon, self.arc_entry_lat, self.arc_entry_lon, self.altitude, self.expected_travel_distance, self.cross_track_error, self.stage), force_mavlink1=force_mavlink1)

class MAVLink_gimbal_report_message(MAVLink_message):
        '''
        3 axis gimbal measurements.
        '''
        id = MAVLINK_MSG_ID_GIMBAL_REPORT
        name = 'GIMBAL_REPORT'
        fieldnames = ['target_system', 'target_component', 'delta_time', 'delta_angle_x', 'delta_angle_y', 'delta_angle_z', 'delta_velocity_x', 'delta_velocity_y', 'delta_velocity_z', 'joint_roll', 'joint_el', 'joint_az']
        ordered_fieldnames = ['delta_time', 'delta_angle_x', 'delta_angle_y', 'delta_angle_z', 'delta_velocity_x', 'delta_velocity_y', 'delta_velocity_z', 'joint_roll', 'joint_el', 'joint_az', 'target_system', 'target_component']
        fieldtypes = ['uint8_t', 'uint8_t', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"delta_time": "s", "delta_angle_x": "rad", "delta_angle_y": "rad", "delta_angle_z": "rad", "delta_velocity_x": "m/s", "delta_velocity_y": "m/s", "delta_velocity_z": "m/s", "joint_roll": "rad", "joint_el": "rad", "joint_az": "rad"}
        format = '<ffffffffffBB'
        native_format = bytearray('<ffffffffffBB', 'ascii')
        orders = [10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 134
        unpacker = struct.Struct('<ffffffffffBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az):
                MAVLink_message.__init__(self, MAVLink_gimbal_report_message.id, MAVLink_gimbal_report_message.name)
                self._fieldnames = MAVLink_gimbal_report_message.fieldnames
                self._instance_field = MAVLink_gimbal_report_message.instance_field
                self._instance_offset = MAVLink_gimbal_report_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.delta_time = delta_time
                self.delta_angle_x = delta_angle_x
                self.delta_angle_y = delta_angle_y
                self.delta_angle_z = delta_angle_z
                self.delta_velocity_x = delta_velocity_x
                self.delta_velocity_y = delta_velocity_y
                self.delta_velocity_z = delta_velocity_z
                self.joint_roll = joint_roll
                self.joint_el = joint_el
                self.joint_az = joint_az

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 134, struct.pack('<ffffffffffBB', self.delta_time, self.delta_angle_x, self.delta_angle_y, self.delta_angle_z, self.delta_velocity_x, self.delta_velocity_y, self.delta_velocity_z, self.joint_roll, self.joint_el, self.joint_az, self.target_system, self.target_component), force_mavlink1=force_mavlink1)

class MAVLink_gimbal_control_message(MAVLink_message):
        '''
        Control message for rate gimbal.
        '''
        id = MAVLINK_MSG_ID_GIMBAL_CONTROL
        name = 'GIMBAL_CONTROL'
        fieldnames = ['target_system', 'target_component', 'demanded_rate_x', 'demanded_rate_y', 'demanded_rate_z']
        ordered_fieldnames = ['demanded_rate_x', 'demanded_rate_y', 'demanded_rate_z', 'target_system', 'target_component']
        fieldtypes = ['uint8_t', 'uint8_t', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"demanded_rate_x": "rad/s", "demanded_rate_y": "rad/s", "demanded_rate_z": "rad/s"}
        format = '<fffBB'
        native_format = bytearray('<fffBB', 'ascii')
        orders = [3, 4, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 205
        unpacker = struct.Struct('<fffBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z):
                MAVLink_message.__init__(self, MAVLink_gimbal_control_message.id, MAVLink_gimbal_control_message.name)
                self._fieldnames = MAVLink_gimbal_control_message.fieldnames
                self._instance_field = MAVLink_gimbal_control_message.instance_field
                self._instance_offset = MAVLink_gimbal_control_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.demanded_rate_x = demanded_rate_x
                self.demanded_rate_y = demanded_rate_y
                self.demanded_rate_z = demanded_rate_z

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 205, struct.pack('<fffBB', self.demanded_rate_x, self.demanded_rate_y, self.demanded_rate_z, self.target_system, self.target_component), force_mavlink1=force_mavlink1)

class MAVLink_gimbal_torque_cmd_report_message(MAVLink_message):
        '''
        100 Hz gimbal torque command telemetry.
        '''
        id = MAVLINK_MSG_ID_GIMBAL_TORQUE_CMD_REPORT
        name = 'GIMBAL_TORQUE_CMD_REPORT'
        fieldnames = ['target_system', 'target_component', 'rl_torque_cmd', 'el_torque_cmd', 'az_torque_cmd']
        ordered_fieldnames = ['rl_torque_cmd', 'el_torque_cmd', 'az_torque_cmd', 'target_system', 'target_component']
        fieldtypes = ['uint8_t', 'uint8_t', 'int16_t', 'int16_t', 'int16_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<hhhBB'
        native_format = bytearray('<hhhBB', 'ascii')
        orders = [3, 4, 0, 1, 2]
        lengths = [1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0]
        crc_extra = 69
        unpacker = struct.Struct('<hhhBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, rl_torque_cmd, el_torque_cmd, az_torque_cmd):
                MAVLink_message.__init__(self, MAVLink_gimbal_torque_cmd_report_message.id, MAVLink_gimbal_torque_cmd_report_message.name)
                self._fieldnames = MAVLink_gimbal_torque_cmd_report_message.fieldnames
                self._instance_field = MAVLink_gimbal_torque_cmd_report_message.instance_field
                self._instance_offset = MAVLink_gimbal_torque_cmd_report_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.rl_torque_cmd = rl_torque_cmd
                self.el_torque_cmd = el_torque_cmd
                self.az_torque_cmd = az_torque_cmd

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 69, struct.pack('<hhhBB', self.rl_torque_cmd, self.el_torque_cmd, self.az_torque_cmd, self.target_system, self.target_component), force_mavlink1=force_mavlink1)

class MAVLink_gopro_heartbeat_message(MAVLink_message):
        '''
        Heartbeat from a HeroBus attached GoPro.
        '''
        id = MAVLINK_MSG_ID_GOPRO_HEARTBEAT
        name = 'GOPRO_HEARTBEAT'
        fieldnames = ['status', 'capture_mode', 'flags']
        ordered_fieldnames = ['status', 'capture_mode', 'flags']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {"flags": "bitmask"}
        fieldenums_by_name = {"status": "GOPRO_HEARTBEAT_STATUS", "capture_mode": "GOPRO_CAPTURE_MODE", "flags": "GOPRO_HEARTBEAT_FLAGS"}
        fieldunits_by_name = {}
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 101
        unpacker = struct.Struct('<BBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, status, capture_mode, flags):
                MAVLink_message.__init__(self, MAVLink_gopro_heartbeat_message.id, MAVLink_gopro_heartbeat_message.name)
                self._fieldnames = MAVLink_gopro_heartbeat_message.fieldnames
                self._instance_field = MAVLink_gopro_heartbeat_message.instance_field
                self._instance_offset = MAVLink_gopro_heartbeat_message.instance_offset
                self.status = status
                self.capture_mode = capture_mode
                self.flags = flags

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 101, struct.pack('<BBB', self.status, self.capture_mode, self.flags), force_mavlink1=force_mavlink1)

class MAVLink_gopro_get_request_message(MAVLink_message):
        '''
        Request a GOPRO_COMMAND response from the GoPro.
        '''
        id = MAVLINK_MSG_ID_GOPRO_GET_REQUEST
        name = 'GOPRO_GET_REQUEST'
        fieldnames = ['target_system', 'target_component', 'cmd_id']
        ordered_fieldnames = ['target_system', 'target_component', 'cmd_id']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"cmd_id": "GOPRO_COMMAND"}
        fieldunits_by_name = {}
        format = '<BBB'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 1]
        array_lengths = [0, 0, 0]
        crc_extra = 50
        unpacker = struct.Struct('<BBB')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, cmd_id):
                MAVLink_message.__init__(self, MAVLink_gopro_get_request_message.id, MAVLink_gopro_get_request_message.name)
                self._fieldnames = MAVLink_gopro_get_request_message.fieldnames
                self._instance_field = MAVLink_gopro_get_request_message.instance_field
                self._instance_offset = MAVLink_gopro_get_request_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.cmd_id = cmd_id

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 50, struct.pack('<BBB', self.target_system, self.target_component, self.cmd_id), force_mavlink1=force_mavlink1)

class MAVLink_gopro_get_response_message(MAVLink_message):
        '''
        Response from a GOPRO_COMMAND get request.
        '''
        id = MAVLINK_MSG_ID_GOPRO_GET_RESPONSE
        name = 'GOPRO_GET_RESPONSE'
        fieldnames = ['cmd_id', 'status', 'value']
        ordered_fieldnames = ['cmd_id', 'status', 'value']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"cmd_id": "GOPRO_COMMAND", "status": "GOPRO_REQUEST_STATUS"}
        fieldunits_by_name = {}
        format = '<BB4B'
        native_format = bytearray('<BBB', 'ascii')
        orders = [0, 1, 2]
        lengths = [1, 1, 4]
        array_lengths = [0, 0, 4]
        crc_extra = 202
        unpacker = struct.Struct('<BB4B')
        instance_field = None
        instance_offset = -1

        def __init__(self, cmd_id, status, value):
                MAVLink_message.__init__(self, MAVLink_gopro_get_response_message.id, MAVLink_gopro_get_response_message.name)
                self._fieldnames = MAVLink_gopro_get_response_message.fieldnames
                self._instance_field = MAVLink_gopro_get_response_message.instance_field
                self._instance_offset = MAVLink_gopro_get_response_message.instance_offset
                self.cmd_id = cmd_id
                self.status = status
                self.value = value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 202, struct.pack('<BB4B', self.cmd_id, self.status, self.value[0], self.value[1], self.value[2], self.value[3]), force_mavlink1=force_mavlink1)

class MAVLink_gopro_set_request_message(MAVLink_message):
        '''
        Request to set a GOPRO_COMMAND with a desired.
        '''
        id = MAVLINK_MSG_ID_GOPRO_SET_REQUEST
        name = 'GOPRO_SET_REQUEST'
        fieldnames = ['target_system', 'target_component', 'cmd_id', 'value']
        ordered_fieldnames = ['target_system', 'target_component', 'cmd_id', 'value']
        fieldtypes = ['uint8_t', 'uint8_t', 'uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"cmd_id": "GOPRO_COMMAND"}
        fieldunits_by_name = {}
        format = '<BBB4B'
        native_format = bytearray('<BBBB', 'ascii')
        orders = [0, 1, 2, 3]
        lengths = [1, 1, 1, 4]
        array_lengths = [0, 0, 0, 4]
        crc_extra = 17
        unpacker = struct.Struct('<BBB4B')
        instance_field = None
        instance_offset = -1

        def __init__(self, target_system, target_component, cmd_id, value):
                MAVLink_message.__init__(self, MAVLink_gopro_set_request_message.id, MAVLink_gopro_set_request_message.name)
                self._fieldnames = MAVLink_gopro_set_request_message.fieldnames
                self._instance_field = MAVLink_gopro_set_request_message.instance_field
                self._instance_offset = MAVLink_gopro_set_request_message.instance_offset
                self.target_system = target_system
                self.target_component = target_component
                self.cmd_id = cmd_id
                self.value = value

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 17, struct.pack('<BBB4B', self.target_system, self.target_component, self.cmd_id, self.value[0], self.value[1], self.value[2], self.value[3]), force_mavlink1=force_mavlink1)

class MAVLink_gopro_set_response_message(MAVLink_message):
        '''
        Response from a GOPRO_COMMAND set request.
        '''
        id = MAVLINK_MSG_ID_GOPRO_SET_RESPONSE
        name = 'GOPRO_SET_RESPONSE'
        fieldnames = ['cmd_id', 'status']
        ordered_fieldnames = ['cmd_id', 'status']
        fieldtypes = ['uint8_t', 'uint8_t']
        fielddisplays_by_name = {}
        fieldenums_by_name = {"cmd_id": "GOPRO_COMMAND", "status": "GOPRO_REQUEST_STATUS"}
        fieldunits_by_name = {}
        format = '<BB'
        native_format = bytearray('<BB', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 162
        unpacker = struct.Struct('<BB')
        instance_field = None
        instance_offset = -1

        def __init__(self, cmd_id, status):
                MAVLink_message.__init__(self, MAVLink_gopro_set_response_message.id, MAVLink_gopro_set_response_message.name)
                self._fieldnames = MAVLink_gopro_set_response_message.fieldnames
                self._instance_field = MAVLink_gopro_set_response_message.instance_field
                self._instance_offset = MAVLink_gopro_set_response_message.instance_offset
                self.cmd_id = cmd_id
                self.status = status

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 162, struct.pack('<BB', self.cmd_id, self.status), force_mavlink1=force_mavlink1)

class MAVLink_efi_status_message(MAVLink_message):
        '''
        EFI status output
        '''
        id = MAVLINK_MSG_ID_EFI_STATUS
        name = 'EFI_STATUS'
        fieldnames = ['health', 'ecu_index', 'rpm', 'fuel_consumed', 'fuel_flow', 'engine_load', 'throttle_position', 'spark_dwell_time', 'barometric_pressure', 'intake_manifold_pressure', 'intake_manifold_temperature', 'cylinder_head_temperature', 'ignition_timing', 'injection_time', 'exhaust_gas_temperature', 'throttle_out', 'pt_compensation']
        ordered_fieldnames = ['ecu_index', 'rpm', 'fuel_consumed', 'fuel_flow', 'engine_load', 'throttle_position', 'spark_dwell_time', 'barometric_pressure', 'intake_manifold_pressure', 'intake_manifold_temperature', 'cylinder_head_temperature', 'ignition_timing', 'injection_time', 'exhaust_gas_temperature', 'throttle_out', 'pt_compensation', 'health']
        fieldtypes = ['uint8_t', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {"fuel_consumed": "g", "fuel_flow": "g/min", "engine_load": "%", "throttle_position": "%", "spark_dwell_time": "ms", "barometric_pressure": "kPa", "intake_manifold_pressure": "kPa", "intake_manifold_temperature": "degC", "cylinder_head_temperature": "degC", "ignition_timing": "deg", "injection_time": "ms", "exhaust_gas_temperature": "degC", "throttle_out": "%"}
        format = '<ffffffffffffffffB'
        native_format = bytearray('<ffffffffffffffffB', 'ascii')
        orders = [16, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
        lengths = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        array_lengths = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        crc_extra = 208
        unpacker = struct.Struct('<ffffffffffffffffB')
        instance_field = None
        instance_offset = -1

        def __init__(self, health, ecu_index, rpm, fuel_consumed, fuel_flow, engine_load, throttle_position, spark_dwell_time, barometric_pressure, intake_manifold_pressure, intake_manifold_temperature, cylinder_head_temperature, ignition_timing, injection_time, exhaust_gas_temperature, throttle_out, pt_compensation):
                MAVLink_message.__init__(self, MAVLink_efi_status_message.id, MAVLink_efi_status_message.name)
                self._fieldnames = MAVLink_efi_status_message.fieldnames
                self._instance_field = MAVLink_efi_status_message.instance_field
                self._instance_offset = MAVLink_efi_status_message.instance_offset
                self.health = health
                self.ecu_index = ecu_index
                self.rpm = rpm
                self.fuel_consumed = fuel_consumed
                self.fuel_flow = fuel_flow
                self.engine_load = engine_load
                self.throttle_position = throttle_position
                self.spark_dwell_time = spark_dwell_time
                self.barometric_pressure = barometric_pressure
                self.intake_manifold_pressure = intake_manifold_pressure
                self.intake_manifold_temperature = intake_manifold_temperature
                self.cylinder_head_temperature = cylinder_head_temperature
                self.ignition_timing = ignition_timing
                self.injection_time = injection_time
                self.exhaust_gas_temperature = exhaust_gas_temperature
                self.throttle_out = throttle_out
                self.pt_compensation = pt_compensation

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 208, struct.pack('<ffffffffffffffffB', self.ecu_index, self.rpm, self.fuel_consumed, self.fuel_flow, self.engine_load, self.throttle_position, self.spark_dwell_time, self.barometric_pressure, self.intake_manifold_pressure, self.intake_manifold_temperature, self.cylinder_head_temperature, self.ignition_timing, self.injection_time, self.exhaust_gas_temperature, self.throttle_out, self.pt_compensation, self.health), force_mavlink1=force_mavlink1)

class MAVLink_rpm_message(MAVLink_message):
        '''
        RPM sensor output.
        '''
        id = MAVLINK_MSG_ID_RPM
        name = 'RPM'
        fieldnames = ['rpm1', 'rpm2']
        ordered_fieldnames = ['rpm1', 'rpm2']
        fieldtypes = ['float', 'float']
        fielddisplays_by_name = {}
        fieldenums_by_name = {}
        fieldunits_by_name = {}
        format = '<ff'
        native_format = bytearray('<ff', 'ascii')
        orders = [0, 1]
        lengths = [1, 1]
        array_lengths = [0, 0]
        crc_extra = 207
        unpacker = struct.Struct('<ff')
        instance_field = None
        instance_offset = -1

        def __init__(self, rpm1, rpm2):
                MAVLink_message.__init__(self, MAVLink_rpm_message.id, MAVLink_rpm_message.name)
                self._fieldnames = MAVLink_rpm_message.fieldnames
                self._instance_field = MAVLink_rpm_message.instance_field
                self._instance_offset = MAVLink_rpm_message.instance_offset
                self.rpm1 = rpm1
                self.rpm2 = rpm2

        def pack(self, mav, force_mavlink1=False):
                return MAVLink_message.pack(self, mav, 207, struct.pack('<ff', self.rpm1, self.rpm2), force_mavlink1=force_mavlink1)


mavlink_map = {
        MAVLINK_MSG_ID_SENSOR_OFFSETS : MAVLink_sensor_offsets_message,
        MAVLINK_MSG_ID_SET_MAG_OFFSETS : MAVLink_set_mag_offsets_message,
        MAVLINK_MSG_ID_MEMINFO : MAVLink_meminfo_message,
        MAVLINK_MSG_ID_AP_ADC : MAVLink_ap_adc_message,
        MAVLINK_MSG_ID_DIGICAM_CONFIGURE : MAVLink_digicam_configure_message,
        MAVLINK_MSG_ID_DIGICAM_CONTROL : MAVLink_digicam_control_message,
        MAVLINK_MSG_ID_MOUNT_CONFIGURE : MAVLink_mount_configure_message,
        MAVLINK_MSG_ID_MOUNT_CONTROL : MAVLink_mount_control_message,
        MAVLINK_MSG_ID_MOUNT_STATUS : MAVLink_mount_status_message,
        MAVLINK_MSG_ID_FENCE_POINT : MAVLink_fence_point_message,
        MAVLINK_MSG_ID_FENCE_FETCH_POINT : MAVLink_fence_fetch_point_message,
        MAVLINK_MSG_ID_AHRS : MAVLink_ahrs_message,
        MAVLINK_MSG_ID_SIMSTATE : MAVLink_simstate_message,
        MAVLINK_MSG_ID_HWSTATUS : MAVLink_hwstatus_message,
        MAVLINK_MSG_ID_RADIO : MAVLink_radio_message,
        MAVLINK_MSG_ID_LIMITS_STATUS : MAVLink_limits_status_message,
        MAVLINK_MSG_ID_WIND : MAVLink_wind_message,
        MAVLINK_MSG_ID_DATA16 : MAVLink_data16_message,
        MAVLINK_MSG_ID_DATA32 : MAVLink_data32_message,
        MAVLINK_MSG_ID_DATA64 : MAVLink_data64_message,
        MAVLINK_MSG_ID_DATA96 : MAVLink_data96_message,
        MAVLINK_MSG_ID_RANGEFINDER : MAVLink_rangefinder_message,
        MAVLINK_MSG_ID_AIRSPEED_AUTOCAL : MAVLink_airspeed_autocal_message,
        MAVLINK_MSG_ID_RALLY_POINT : MAVLink_rally_point_message,
        MAVLINK_MSG_ID_RALLY_FETCH_POINT : MAVLink_rally_fetch_point_message,
        MAVLINK_MSG_ID_COMPASSMOT_STATUS : MAVLink_compassmot_status_message,
        MAVLINK_MSG_ID_AHRS2 : MAVLink_ahrs2_message,
        MAVLINK_MSG_ID_CAMERA_STATUS : MAVLink_camera_status_message,
        MAVLINK_MSG_ID_CAMERA_FEEDBACK : MAVLink_camera_feedback_message,
        MAVLINK_MSG_ID_BATTERY2 : MAVLink_battery2_message,
        MAVLINK_MSG_ID_AHRS3 : MAVLink_ahrs3_message,
        MAVLINK_MSG_ID_AUTOPILOT_VERSION_REQUEST : MAVLink_autopilot_version_request_message,
        MAVLINK_MSG_ID_REMOTE_LOG_DATA_BLOCK : MAVLink_remote_log_data_block_message,
        MAVLINK_MSG_ID_REMOTE_LOG_BLOCK_STATUS : MAVLink_remote_log_block_status_message,
        MAVLINK_MSG_ID_LED_CONTROL : MAVLink_led_control_message,
        MAVLINK_MSG_ID_MAG_CAL_PROGRESS : MAVLink_mag_cal_progress_message,
        MAVLINK_MSG_ID_MAG_CAL_REPORT : MAVLink_mag_cal_report_message,
        MAVLINK_MSG_ID_EKF_STATUS_REPORT : MAVLink_ekf_status_report_message,
        MAVLINK_MSG_ID_PID_TUNING : MAVLink_pid_tuning_message,
        MAVLINK_MSG_ID_DEEPSTALL : MAVLink_deepstall_message,
        MAVLINK_MSG_ID_GIMBAL_REPORT : MAVLink_gimbal_report_message,
        MAVLINK_MSG_ID_GIMBAL_CONTROL : MAVLink_gimbal_control_message,
        MAVLINK_MSG_ID_GIMBAL_TORQUE_CMD_REPORT : MAVLink_gimbal_torque_cmd_report_message,
        MAVLINK_MSG_ID_GOPRO_HEARTBEAT : MAVLink_gopro_heartbeat_message,
        MAVLINK_MSG_ID_GOPRO_GET_REQUEST : MAVLink_gopro_get_request_message,
        MAVLINK_MSG_ID_GOPRO_GET_RESPONSE : MAVLink_gopro_get_response_message,
        MAVLINK_MSG_ID_GOPRO_SET_REQUEST : MAVLink_gopro_set_request_message,
        MAVLINK_MSG_ID_GOPRO_SET_RESPONSE : MAVLink_gopro_set_response_message,
        MAVLINK_MSG_ID_EFI_STATUS : MAVLink_efi_status_message,
        MAVLINK_MSG_ID_RPM : MAVLink_rpm_message,
}

class MAVError(Exception):
        '''MAVLink error class'''
        def __init__(self, msg):
            Exception.__init__(self, msg)
            self.message = msg

class MAVString(str):
        '''NUL terminated string'''
        def __init__(self, s):
                str.__init__(self)
        def __str__(self):
            i = self.find(chr(0))
            if i == -1:
                return self[:]
            return self[0:i]

class MAVLink_bad_data(MAVLink_message):
        '''
        a piece of bad data in a mavlink stream
        '''
        def __init__(self, data, reason):
                MAVLink_message.__init__(self, MAVLINK_MSG_ID_BAD_DATA, 'BAD_DATA')
                self._fieldnames = ['data', 'reason']
                self.data = data
                self.reason = reason
                self._msgbuf = data
                self._instance_field = None

        def __str__(self):
            '''Override the __str__ function from MAVLink_messages because non-printable characters are common in to be the reason for this message to exist.'''
            return '%s {%s, data:%s}' % (self._type, self.reason, [('%x' % ord(i) if isinstance(i, str) else '%x' % i) for i in self.data])

class MAVLinkSigning(object):
    '''MAVLink signing state class'''
    def __init__(self):
        self.secret_key = None
        self.timestamp = 0
        self.link_id = 0
        self.sign_outgoing = False
        self.allow_unsigned_callback = None
        self.stream_timestamps = {}
        self.sig_count = 0
        self.badsig_count = 0
        self.goodsig_count = 0
        self.unsigned_count = 0
        self.reject_count = 0

class MAVLink(object):
        '''MAVLink protocol handling class'''
        def __init__(self, file, srcSystem=0, srcComponent=0, use_native=False):
                self.seq = 0
                self.file = file
                self.srcSystem = srcSystem
                self.srcComponent = srcComponent
                self.callback = None
                self.callback_args = None
                self.callback_kwargs = None
                self.send_callback = None
                self.send_callback_args = None
                self.send_callback_kwargs = None
                self.buf = bytearray()
                self.buf_index = 0
                self.expected_length = HEADER_LEN_V1+2
                self.have_prefix_error = False
                self.robust_parsing = False
                self.protocol_marker = 254
                self.little_endian = True
                self.crc_extra = True
                self.sort_fields = True
                self.total_packets_sent = 0
                self.total_bytes_sent = 0
                self.total_packets_received = 0
                self.total_bytes_received = 0
                self.total_receive_errors = 0
                self.startup_time = time.time()
                self.signing = MAVLinkSigning()
                if native_supported and (use_native or native_testing or native_force):
                    print("NOTE: mavnative is currently beta-test code")
                    self.native = mavnative.NativeConnection(MAVLink_message, mavlink_map)
                else:
                    self.native = None
                if native_testing:
                    self.test_buf = bytearray()
                self.mav20_unpacker = struct.Struct('<cBBBBBBHB')
                self.mav10_unpacker = struct.Struct('<cBBBBB')
                self.mav20_h3_unpacker = struct.Struct('BBB')
                self.mav_csum_unpacker = struct.Struct('<H')
                self.mav_sign_unpacker = struct.Struct('<IH')

        def set_callback(self, callback, *args, **kwargs):
            self.callback = callback
            self.callback_args = args
            self.callback_kwargs = kwargs

        def set_send_callback(self, callback, *args, **kwargs):
            self.send_callback = callback
            self.send_callback_args = args
            self.send_callback_kwargs = kwargs

        def send(self, mavmsg, force_mavlink1=False):
                '''send a MAVLink message'''
                buf = mavmsg.pack(self, force_mavlink1=force_mavlink1)
                self.file.write(buf)
                self.seq = (self.seq + 1) % 256
                self.total_packets_sent += 1
                self.total_bytes_sent += len(buf)
                if self.send_callback:
                    self.send_callback(mavmsg, *self.send_callback_args, **self.send_callback_kwargs)

        def buf_len(self):
            return len(self.buf) - self.buf_index

        def bytes_needed(self):
            '''return number of bytes needed for next parsing stage'''
            if self.native:
                ret = self.native.expected_length - self.buf_len()
            else:
                ret = self.expected_length - self.buf_len()

            if ret <= 0:
                return 1
            return ret

        def __parse_char_native(self, c):
            '''this method exists only to see in profiling results'''
            m = self.native.parse_chars(c)
            return m

        def __callbacks(self, msg):
            '''this method exists only to make profiling results easier to read'''
            if self.callback:
                self.callback(msg, *self.callback_args, **self.callback_kwargs)

        def parse_char(self, c):
            '''input some data bytes, possibly returning a new message'''
            self.buf.extend(c)

            self.total_bytes_received += len(c)

            if self.native:
                if native_testing:
                    self.test_buf.extend(c)
                    m = self.__parse_char_native(self.test_buf)
                    m2 = self.__parse_char_legacy()
                    if m2 != m:
                        print("Native: %s\nLegacy: %s\n" % (m, m2))
                        raise Exception('Native vs. Legacy mismatch')
                else:
                    m = self.__parse_char_native(self.buf)
            else:
                m = self.__parse_char_legacy()

            if m is not None:
                self.total_packets_received += 1
                self.__callbacks(m)
            else:
                # XXX The idea here is if we've read something and there's nothing left in
                # the buffer, reset it to 0 which frees the memory
                if self.buf_len() == 0 and self.buf_index != 0:
                    self.buf = bytearray()
                    self.buf_index = 0

            return m

        def __parse_char_legacy(self):
            '''input some data bytes, possibly returning a new message (uses no native code)'''
            header_len = HEADER_LEN_V1
            if self.buf_len() >= 1 and self.buf[self.buf_index] == PROTOCOL_MARKER_V2:
                header_len = HEADER_LEN_V2

            if self.buf_len() >= 1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V1 and self.buf[self.buf_index] != PROTOCOL_MARKER_V2:
                magic = self.buf[self.buf_index]
                self.buf_index += 1
                if self.robust_parsing:
                    m = MAVLink_bad_data(bytearray([magic]), 'Bad prefix')
                    self.expected_length = header_len+2
                    self.total_receive_errors += 1
                    return m
                if self.have_prefix_error:
                    return None
                self.have_prefix_error = True
                self.total_receive_errors += 1
                raise MAVError("invalid MAVLink prefix '%s'" % magic)
            self.have_prefix_error = False
            if self.buf_len() >= 3:
                sbuf = self.buf[self.buf_index:3+self.buf_index]
                if sys.version_info.major < 3:
                    sbuf = str(sbuf)
                (magic, self.expected_length, incompat_flags) = self.mav20_h3_unpacker.unpack(sbuf)
                if magic == PROTOCOL_MARKER_V2 and (incompat_flags & MAVLINK_IFLAG_SIGNED):
                        self.expected_length += MAVLINK_SIGNATURE_BLOCK_LEN
                self.expected_length += header_len + 2
            if self.expected_length >= (header_len+2) and self.buf_len() >= self.expected_length:
                mbuf = array.array('B', self.buf[self.buf_index:self.buf_index+self.expected_length])
                self.buf_index += self.expected_length
                self.expected_length = header_len+2
                if self.robust_parsing:
                    try:
                        if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                            raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                        m = self.decode(mbuf)
                    except MAVError as reason:
                        m = MAVLink_bad_data(mbuf, reason.message)
                        self.total_receive_errors += 1
                else:
                    if magic == PROTOCOL_MARKER_V2 and (incompat_flags & ~MAVLINK_IFLAG_SIGNED) != 0:
                        raise MAVError('invalid incompat_flags 0x%x 0x%x %u' % (incompat_flags, magic, self.expected_length))
                    m = self.decode(mbuf)
                return m
            return None

        def parse_buffer(self, s):
            '''input some data bytes, possibly returning a list of new messages'''
            m = self.parse_char(s)
            if m is None:
                return None
            ret = [m]
            while True:
                m = self.parse_char("")
                if m is None:
                    return ret
                ret.append(m)
            return ret

        def check_signature(self, msgbuf, srcSystem, srcComponent):
            '''check signature on incoming message'''
            if isinstance(msgbuf, array.array):
                msgbuf = msgbuf.tostring()
            timestamp_buf = msgbuf[-12:-6]
            link_id = msgbuf[-13]
            (tlow, thigh) = self.mav_sign_unpacker.unpack(timestamp_buf)
            timestamp = tlow + (thigh<<32)

            # see if the timestamp is acceptable
            stream_key = (link_id,srcSystem,srcComponent)
            if stream_key in self.signing.stream_timestamps:
                if timestamp <= self.signing.stream_timestamps[stream_key]:
                    # reject old timestamp
                    # print('old timestamp')
                    return False
            else:
                # a new stream has appeared. Accept the timestamp if it is at most
                # one minute behind our current timestamp
                if timestamp + 6000*1000 < self.signing.timestamp:
                    # print('bad new stream ', timestamp/(100.0*1000*60*60*24*365), self.signing.timestamp/(100.0*1000*60*60*24*365))
                    return False
                self.signing.stream_timestamps[stream_key] = timestamp
                # print('new stream')

            h = hashlib.new('sha256')
            h.update(self.signing.secret_key)
            h.update(msgbuf[:-6])
            if str(type(msgbuf)) == "<class 'bytes'>":
                # Python 3
                sig1 = h.digest()[:6]
                sig2 = msgbuf[-6:]
            else:
                sig1 = str(h.digest())[:6]
                sig2 = str(msgbuf)[-6:]
            if sig1 != sig2:
                # print('sig mismatch')
                return False

            # the timestamp we next send with is the max of the received timestamp and
            # our current timestamp
            self.signing.timestamp = max(self.signing.timestamp, timestamp)
            return True

        # swiped from DFReader.py
        def to_string(self, s):
            '''desperate attempt to convert a string regardless of what garbage we get'''
            try:
                return s.decode("utf-8")
            except Exception as e:
                pass
            try:
                s2 = s.encode('utf-8', 'ignore')
                x = u"%s" % s2
                return s2
            except Exception:
                pass
            # so its a nasty one. Let's grab as many characters as we can
            r = ''
            while s != '':
                try:
                    r2 = r + s[0]
                    s = s[1:]
                    r2 = r2.encode('ascii', 'ignore')
                    x = u"%s" % r2
                    r = r2
                except Exception:
                    break
            return r + '_XXX'

        def decode(self, msgbuf):
                '''decode a buffer as a MAVLink message'''
                # decode the header
                if msgbuf[0] != PROTOCOL_MARKER_V1:
                    headerlen = 10
                    try:
                        magic, mlen, incompat_flags, compat_flags, seq, srcSystem, srcComponent, msgIdlow, msgIdhigh = self.mav20_unpacker.unpack(msgbuf[:headerlen])
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    msgId = msgIdlow | (msgIdhigh<<16)
                    mapkey = msgId
                else:
                    headerlen = 6
                    try:
                        magic, mlen, seq, srcSystem, srcComponent, msgId = self.mav10_unpacker.unpack(msgbuf[:headerlen])
                        incompat_flags = 0
                        compat_flags = 0
                    except struct.error as emsg:
                        raise MAVError('Unable to unpack MAVLink header: %s' % emsg)
                    mapkey = msgId
                if (incompat_flags & MAVLINK_IFLAG_SIGNED) != 0:
                    signature_len = MAVLINK_SIGNATURE_BLOCK_LEN
                else:
                    signature_len = 0

                if ord(magic) != PROTOCOL_MARKER_V1 and ord(magic) != PROTOCOL_MARKER_V2:
                    raise MAVError("invalid MAVLink prefix '%s'" % magic)
                if mlen != len(msgbuf)-(headerlen+2+signature_len):
                    raise MAVError('invalid MAVLink message length. Got %u expected %u, msgId=%u headerlen=%u' % (len(msgbuf)-(headerlen+2+signature_len), mlen, msgId, headerlen))

                if not mapkey in mavlink_map:
                    raise MAVError('unknown MAVLink message ID %s' % str(mapkey))

                # decode the payload
                type = mavlink_map[mapkey]
                fmt = type.format
                order_map = type.orders
                len_map = type.lengths
                crc_extra = type.crc_extra

                # decode the checksum
                try:
                    crc, = self.mav_csum_unpacker.unpack(msgbuf[-(2+signature_len):][:2])
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink CRC: %s' % emsg)
                crcbuf = msgbuf[1:-(2+signature_len)]
                if True: # using CRC extra
                    crcbuf.append(crc_extra)
                crc2 = x25crc(crcbuf)
                if crc != crc2.crc:
                    raise MAVError('invalid MAVLink CRC in msgID %u 0x%04x should be 0x%04x' % (msgId, crc, crc2.crc))

                sig_ok = False
                if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                    self.signing.sig_count += 1
                if self.signing.secret_key is not None:
                    accept_signature = False
                    if signature_len == MAVLINK_SIGNATURE_BLOCK_LEN:
                        sig_ok = self.check_signature(msgbuf, srcSystem, srcComponent)
                        accept_signature = sig_ok
                        if sig_ok:
                            self.signing.goodsig_count += 1
                        else:
                            self.signing.badsig_count += 1
                        if not accept_signature and self.signing.allow_unsigned_callback is not None:
                            accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                            if accept_signature:
                                self.signing.unsigned_count += 1
                            else:
                                self.signing.reject_count += 1
                    elif self.signing.allow_unsigned_callback is not None:
                        accept_signature = self.signing.allow_unsigned_callback(self, msgId)
                        if accept_signature:
                            self.signing.unsigned_count += 1
                        else:
                            self.signing.reject_count += 1
                    if not accept_signature:
                        raise MAVError('Invalid signature')

                csize = type.unpacker.size
                mbuf = msgbuf[headerlen:-(2+signature_len)]
                if len(mbuf) < csize:
                    # zero pad to give right size
                    mbuf.extend([0]*(csize - len(mbuf)))
                if len(mbuf) < csize:
                    raise MAVError('Bad message of type %s length %u needs %s' % (
                        type, len(mbuf), csize))
                mbuf = mbuf[:csize]
                try:
                    t = type.unpacker.unpack(mbuf)
                except struct.error as emsg:
                    raise MAVError('Unable to unpack MAVLink payload type=%s fmt=%s payloadLength=%u: %s' % (
                        type, fmt, len(mbuf), emsg))

                tlist = list(t)
                # handle sorted fields
                if True:
                    t = tlist[:]
                    if sum(len_map) == len(len_map):
                        # message has no arrays in it
                        for i in range(0, len(tlist)):
                            tlist[i] = t[order_map[i]]
                    else:
                        # message has some arrays
                        tlist = []
                        for i in range(0, len(order_map)):
                            order = order_map[i]
                            L = len_map[order]
                            tip = sum(len_map[:order])
                            field = t[tip]
                            if L == 1 or isinstance(field, str):
                                tlist.append(field)
                            else:
                                tlist.append(t[tip:(tip + L)])

                # terminate any strings
                for i in range(0, len(tlist)):
                    if type.fieldtypes[i] == 'char':
                        if sys.version_info.major >= 3:
                            tlist[i] = self.to_string(tlist[i])
                        tlist[i] = str(MAVString(tlist[i]))
                t = tuple(tlist)
                # construct the message object
                try:
                    m = type(*t)
                except Exception as emsg:
                    raise MAVError('Unable to instantiate MAVLink message of type %s : %s' % (type, emsg))
                m._signed = sig_ok
                if m._signed:
                    m._link_id = msgbuf[-13]
                m._msgbuf = msgbuf
                m._payload = msgbuf[6:-(2+signature_len)]
                m._crc = crc
                m._header = MAVLink_header(msgId, incompat_flags, compat_flags, mlen, seq, srcSystem, srcComponent)
                return m
        def sensor_offsets_encode(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z):
                '''
                Offsets and calibrations values for hardware sensors. This makes it
                easier to debug the calibration process.

                mag_ofs_x                 : Magnetometer X offset. (type:int16_t)
                mag_ofs_y                 : Magnetometer Y offset. (type:int16_t)
                mag_ofs_z                 : Magnetometer Z offset. (type:int16_t)
                mag_declination           : Magnetic declination. [rad] (type:float)
                raw_press                 : Raw pressure from barometer. (type:int32_t)
                raw_temp                  : Raw temperature from barometer. (type:int32_t)
                gyro_cal_x                : Gyro X calibration. (type:float)
                gyro_cal_y                : Gyro Y calibration. (type:float)
                gyro_cal_z                : Gyro Z calibration. (type:float)
                accel_cal_x               : Accel X calibration. (type:float)
                accel_cal_y               : Accel Y calibration. (type:float)
                accel_cal_z               : Accel Z calibration. (type:float)

                '''
                return MAVLink_sensor_offsets_message(mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z)

        def sensor_offsets_send(self, mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z, force_mavlink1=False):
                '''
                Offsets and calibrations values for hardware sensors. This makes it
                easier to debug the calibration process.

                mag_ofs_x                 : Magnetometer X offset. (type:int16_t)
                mag_ofs_y                 : Magnetometer Y offset. (type:int16_t)
                mag_ofs_z                 : Magnetometer Z offset. (type:int16_t)
                mag_declination           : Magnetic declination. [rad] (type:float)
                raw_press                 : Raw pressure from barometer. (type:int32_t)
                raw_temp                  : Raw temperature from barometer. (type:int32_t)
                gyro_cal_x                : Gyro X calibration. (type:float)
                gyro_cal_y                : Gyro Y calibration. (type:float)
                gyro_cal_z                : Gyro Z calibration. (type:float)
                accel_cal_x               : Accel X calibration. (type:float)
                accel_cal_y               : Accel Y calibration. (type:float)
                accel_cal_z               : Accel Z calibration. (type:float)

                '''
                return self.send(self.sensor_offsets_encode(mag_ofs_x, mag_ofs_y, mag_ofs_z, mag_declination, raw_press, raw_temp, gyro_cal_x, gyro_cal_y, gyro_cal_z, accel_cal_x, accel_cal_y, accel_cal_z), force_mavlink1=force_mavlink1)

        def set_mag_offsets_encode(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z):
                '''
                Set the magnetometer offsets

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                mag_ofs_x                 : Magnetometer X offset. (type:int16_t)
                mag_ofs_y                 : Magnetometer Y offset. (type:int16_t)
                mag_ofs_z                 : Magnetometer Z offset. (type:int16_t)

                '''
                return MAVLink_set_mag_offsets_message(target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z)

        def set_mag_offsets_send(self, target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z, force_mavlink1=False):
                '''
                Set the magnetometer offsets

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                mag_ofs_x                 : Magnetometer X offset. (type:int16_t)
                mag_ofs_y                 : Magnetometer Y offset. (type:int16_t)
                mag_ofs_z                 : Magnetometer Z offset. (type:int16_t)

                '''
                return self.send(self.set_mag_offsets_encode(target_system, target_component, mag_ofs_x, mag_ofs_y, mag_ofs_z), force_mavlink1=force_mavlink1)

        def meminfo_encode(self, brkval, freemem):
                '''
                State of APM memory.

                brkval                    : Heap top. (type:uint16_t)
                freemem                   : Free memory. [bytes] (type:uint16_t)

                '''
                return MAVLink_meminfo_message(brkval, freemem)

        def meminfo_send(self, brkval, freemem, force_mavlink1=False):
                '''
                State of APM memory.

                brkval                    : Heap top. (type:uint16_t)
                freemem                   : Free memory. [bytes] (type:uint16_t)

                '''
                return self.send(self.meminfo_encode(brkval, freemem), force_mavlink1=force_mavlink1)

        def ap_adc_encode(self, adc1, adc2, adc3, adc4, adc5, adc6):
                '''
                Raw ADC output.

                adc1                      : ADC output 1. (type:uint16_t)
                adc2                      : ADC output 2. (type:uint16_t)
                adc3                      : ADC output 3. (type:uint16_t)
                adc4                      : ADC output 4. (type:uint16_t)
                adc5                      : ADC output 5. (type:uint16_t)
                adc6                      : ADC output 6. (type:uint16_t)

                '''
                return MAVLink_ap_adc_message(adc1, adc2, adc3, adc4, adc5, adc6)

        def ap_adc_send(self, adc1, adc2, adc3, adc4, adc5, adc6, force_mavlink1=False):
                '''
                Raw ADC output.

                adc1                      : ADC output 1. (type:uint16_t)
                adc2                      : ADC output 2. (type:uint16_t)
                adc3                      : ADC output 3. (type:uint16_t)
                adc4                      : ADC output 4. (type:uint16_t)
                adc5                      : ADC output 5. (type:uint16_t)
                adc6                      : ADC output 6. (type:uint16_t)

                '''
                return self.send(self.ap_adc_encode(adc1, adc2, adc3, adc4, adc5, adc6), force_mavlink1=force_mavlink1)

        def digicam_configure_encode(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value):
                '''
                Configure on-board Camera Control System.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                mode                      : Mode enumeration from 1 to N //P, TV, AV, M, etc. (0 means ignore). (type:uint8_t)
                shutter_speed             : Divisor number //e.g. 1000 means 1/1000 (0 means ignore). (type:uint16_t)
                aperture                  : F stop number x 10 //e.g. 28 means 2.8 (0 means ignore). (type:uint8_t)
                iso                       : ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore). (type:uint8_t)
                exposure_type             : Exposure type enumeration from 1 to N (0 means ignore). (type:uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255). //A command sent multiple times will be executed or pooled just once. (type:uint8_t)
                engine_cut_off            : Main engine cut-off time before camera trigger (0 means no cut-off). [ds] (type:uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore). (type:uint8_t)
                extra_value               : Correspondent value to given extra_param. (type:float)

                '''
                return MAVLink_digicam_configure_message(target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value)

        def digicam_configure_send(self, target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value, force_mavlink1=False):
                '''
                Configure on-board Camera Control System.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                mode                      : Mode enumeration from 1 to N //P, TV, AV, M, etc. (0 means ignore). (type:uint8_t)
                shutter_speed             : Divisor number //e.g. 1000 means 1/1000 (0 means ignore). (type:uint16_t)
                aperture                  : F stop number x 10 //e.g. 28 means 2.8 (0 means ignore). (type:uint8_t)
                iso                       : ISO enumeration from 1 to N //e.g. 80, 100, 200, Etc (0 means ignore). (type:uint8_t)
                exposure_type             : Exposure type enumeration from 1 to N (0 means ignore). (type:uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255). //A command sent multiple times will be executed or pooled just once. (type:uint8_t)
                engine_cut_off            : Main engine cut-off time before camera trigger (0 means no cut-off). [ds] (type:uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore). (type:uint8_t)
                extra_value               : Correspondent value to given extra_param. (type:float)

                '''
                return self.send(self.digicam_configure_encode(target_system, target_component, mode, shutter_speed, aperture, iso, exposure_type, command_id, engine_cut_off, extra_param, extra_value), force_mavlink1=force_mavlink1)

        def digicam_control_encode(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value):
                '''
                Control on-board Camera Control System to take shots.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                session                   : 0: stop, 1: start or keep it up //Session control e.g. show/hide lens. (type:uint8_t)
                zoom_pos                  : 1 to N //Zoom's absolute position (0 means ignore). (type:uint8_t)
                zoom_step                 : -100 to 100 //Zooming step value to offset zoom from the current position. (type:int8_t)
                focus_lock                : 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus. (type:uint8_t)
                shot                      : 0: ignore, 1: shot or start filming. (type:uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once. (type:uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore). (type:uint8_t)
                extra_value               : Correspondent value to given extra_param. (type:float)

                '''
                return MAVLink_digicam_control_message(target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value)

        def digicam_control_send(self, target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value, force_mavlink1=False):
                '''
                Control on-board Camera Control System to take shots.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                session                   : 0: stop, 1: start or keep it up //Session control e.g. show/hide lens. (type:uint8_t)
                zoom_pos                  : 1 to N //Zoom's absolute position (0 means ignore). (type:uint8_t)
                zoom_step                 : -100 to 100 //Zooming step value to offset zoom from the current position. (type:int8_t)
                focus_lock                : 0: unlock focus or keep unlocked, 1: lock focus or keep locked, 3: re-lock focus. (type:uint8_t)
                shot                      : 0: ignore, 1: shot or start filming. (type:uint8_t)
                command_id                : Command Identity (incremental loop: 0 to 255)//A command sent multiple times will be executed or pooled just once. (type:uint8_t)
                extra_param               : Extra parameters enumeration (0 means ignore). (type:uint8_t)
                extra_value               : Correspondent value to given extra_param. (type:float)

                '''
                return self.send(self.digicam_control_encode(target_system, target_component, session, zoom_pos, zoom_step, focus_lock, shot, command_id, extra_param, extra_value), force_mavlink1=force_mavlink1)

        def mount_configure_encode(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw):
                '''
                Message to configure a camera mount, directional antenna, etc.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                mount_mode                : Mount operating mode. (type:uint8_t, values:MAV_MOUNT_MODE)
                stab_roll                 : (1 = yes, 0 = no). (type:uint8_t)
                stab_pitch                : (1 = yes, 0 = no). (type:uint8_t)
                stab_yaw                  : (1 = yes, 0 = no). (type:uint8_t)

                '''
                return MAVLink_mount_configure_message(target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw)

        def mount_configure_send(self, target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw, force_mavlink1=False):
                '''
                Message to configure a camera mount, directional antenna, etc.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                mount_mode                : Mount operating mode. (type:uint8_t, values:MAV_MOUNT_MODE)
                stab_roll                 : (1 = yes, 0 = no). (type:uint8_t)
                stab_pitch                : (1 = yes, 0 = no). (type:uint8_t)
                stab_yaw                  : (1 = yes, 0 = no). (type:uint8_t)

                '''
                return self.send(self.mount_configure_encode(target_system, target_component, mount_mode, stab_roll, stab_pitch, stab_yaw), force_mavlink1=force_mavlink1)

        def mount_control_encode(self, target_system, target_component, input_a, input_b, input_c, save_position):
                '''
                Message to control a camera mount, directional antenna, etc.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                input_a                   : Pitch (centi-degrees) or lat (degE7), depending on mount mode. (type:int32_t)
                input_b                   : Roll (centi-degrees) or lon (degE7) depending on mount mode. (type:int32_t)
                input_c                   : Yaw (centi-degrees) or alt (cm) depending on mount mode. (type:int32_t)
                save_position             : If "1" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING). (type:uint8_t)

                '''
                return MAVLink_mount_control_message(target_system, target_component, input_a, input_b, input_c, save_position)

        def mount_control_send(self, target_system, target_component, input_a, input_b, input_c, save_position, force_mavlink1=False):
                '''
                Message to control a camera mount, directional antenna, etc.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                input_a                   : Pitch (centi-degrees) or lat (degE7), depending on mount mode. (type:int32_t)
                input_b                   : Roll (centi-degrees) or lon (degE7) depending on mount mode. (type:int32_t)
                input_c                   : Yaw (centi-degrees) or alt (cm) depending on mount mode. (type:int32_t)
                save_position             : If "1" it will save current trimmed position on EEPROM (just valid for NEUTRAL and LANDING). (type:uint8_t)

                '''
                return self.send(self.mount_control_encode(target_system, target_component, input_a, input_b, input_c, save_position), force_mavlink1=force_mavlink1)

        def mount_status_encode(self, target_system, target_component, pointing_a, pointing_b, pointing_c):
                '''
                Message with some status from APM to GCS about camera or antenna
                mount.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                pointing_a                : Pitch. [cdeg] (type:int32_t)
                pointing_b                : Roll. [cdeg] (type:int32_t)
                pointing_c                : Yaw. [cdeg] (type:int32_t)

                '''
                return MAVLink_mount_status_message(target_system, target_component, pointing_a, pointing_b, pointing_c)

        def mount_status_send(self, target_system, target_component, pointing_a, pointing_b, pointing_c, force_mavlink1=False):
                '''
                Message with some status from APM to GCS about camera or antenna
                mount.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                pointing_a                : Pitch. [cdeg] (type:int32_t)
                pointing_b                : Roll. [cdeg] (type:int32_t)
                pointing_c                : Yaw. [cdeg] (type:int32_t)

                '''
                return self.send(self.mount_status_encode(target_system, target_component, pointing_a, pointing_b, pointing_c), force_mavlink1=force_mavlink1)

        def fence_point_encode(self, target_system, target_component, idx, count, lat, lng):
                '''
                A fence point. Used to set a point when from GCS -> MAV. Also used to
                return a point from MAV -> GCS.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 1, 0 is for return point). (type:uint8_t)
                count                     : Total number of points (for sanity checking). (type:uint8_t)
                lat                       : Latitude of point. [deg] (type:float)
                lng                       : Longitude of point. [deg] (type:float)

                '''
                return MAVLink_fence_point_message(target_system, target_component, idx, count, lat, lng)

        def fence_point_send(self, target_system, target_component, idx, count, lat, lng, force_mavlink1=False):
                '''
                A fence point. Used to set a point when from GCS -> MAV. Also used to
                return a point from MAV -> GCS.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 1, 0 is for return point). (type:uint8_t)
                count                     : Total number of points (for sanity checking). (type:uint8_t)
                lat                       : Latitude of point. [deg] (type:float)
                lng                       : Longitude of point. [deg] (type:float)

                '''
                return self.send(self.fence_point_encode(target_system, target_component, idx, count, lat, lng), force_mavlink1=force_mavlink1)

        def fence_fetch_point_encode(self, target_system, target_component, idx):
                '''
                Request a current fence point from MAV.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 1, 0 is for return point). (type:uint8_t)

                '''
                return MAVLink_fence_fetch_point_message(target_system, target_component, idx)

        def fence_fetch_point_send(self, target_system, target_component, idx, force_mavlink1=False):
                '''
                Request a current fence point from MAV.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 1, 0 is for return point). (type:uint8_t)

                '''
                return self.send(self.fence_fetch_point_encode(target_system, target_component, idx), force_mavlink1=force_mavlink1)

        def ahrs_encode(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw):
                '''
                Status of DCM attitude estimator.

                omegaIx                   : X gyro drift estimate. [rad/s] (type:float)
                omegaIy                   : Y gyro drift estimate. [rad/s] (type:float)
                omegaIz                   : Z gyro drift estimate. [rad/s] (type:float)
                accel_weight              : Average accel_weight. (type:float)
                renorm_val                : Average renormalisation value. (type:float)
                error_rp                  : Average error_roll_pitch value. (type:float)
                error_yaw                 : Average error_yaw value. (type:float)

                '''
                return MAVLink_ahrs_message(omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw)

        def ahrs_send(self, omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw, force_mavlink1=False):
                '''
                Status of DCM attitude estimator.

                omegaIx                   : X gyro drift estimate. [rad/s] (type:float)
                omegaIy                   : Y gyro drift estimate. [rad/s] (type:float)
                omegaIz                   : Z gyro drift estimate. [rad/s] (type:float)
                accel_weight              : Average accel_weight. (type:float)
                renorm_val                : Average renormalisation value. (type:float)
                error_rp                  : Average error_roll_pitch value. (type:float)
                error_yaw                 : Average error_yaw value. (type:float)

                '''
                return self.send(self.ahrs_encode(omegaIx, omegaIy, omegaIz, accel_weight, renorm_val, error_rp, error_yaw), force_mavlink1=force_mavlink1)

        def simstate_encode(self, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng):
                '''
                Status of simulation environment, if used.

                roll                      : Roll angle. [rad] (type:float)
                pitch                     : Pitch angle. [rad] (type:float)
                yaw                       : Yaw angle. [rad] (type:float)
                xacc                      : X acceleration. [m/s/s] (type:float)
                yacc                      : Y acceleration. [m/s/s] (type:float)
                zacc                      : Z acceleration. [m/s/s] (type:float)
                xgyro                     : Angular speed around X axis. [rad/s] (type:float)
                ygyro                     : Angular speed around Y axis. [rad/s] (type:float)
                zgyro                     : Angular speed around Z axis. [rad/s] (type:float)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)

                '''
                return MAVLink_simstate_message(roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng)

        def simstate_send(self, roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng, force_mavlink1=False):
                '''
                Status of simulation environment, if used.

                roll                      : Roll angle. [rad] (type:float)
                pitch                     : Pitch angle. [rad] (type:float)
                yaw                       : Yaw angle. [rad] (type:float)
                xacc                      : X acceleration. [m/s/s] (type:float)
                yacc                      : Y acceleration. [m/s/s] (type:float)
                zacc                      : Z acceleration. [m/s/s] (type:float)
                xgyro                     : Angular speed around X axis. [rad/s] (type:float)
                ygyro                     : Angular speed around Y axis. [rad/s] (type:float)
                zgyro                     : Angular speed around Z axis. [rad/s] (type:float)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)

                '''
                return self.send(self.simstate_encode(roll, pitch, yaw, xacc, yacc, zacc, xgyro, ygyro, zgyro, lat, lng), force_mavlink1=force_mavlink1)

        def hwstatus_encode(self, Vcc, I2Cerr):
                '''
                Status of key hardware.

                Vcc                       : Board voltage. [mV] (type:uint16_t)
                I2Cerr                    : I2C error count. (type:uint8_t)

                '''
                return MAVLink_hwstatus_message(Vcc, I2Cerr)

        def hwstatus_send(self, Vcc, I2Cerr, force_mavlink1=False):
                '''
                Status of key hardware.

                Vcc                       : Board voltage. [mV] (type:uint16_t)
                I2Cerr                    : I2C error count. (type:uint8_t)

                '''
                return self.send(self.hwstatus_encode(Vcc, I2Cerr), force_mavlink1=force_mavlink1)

        def radio_encode(self, rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed):
                '''
                Status generated by radio.

                rssi                      : Local signal strength. (type:uint8_t)
                remrssi                   : Remote signal strength. (type:uint8_t)
                txbuf                     : How full the tx buffer is. [%] (type:uint8_t)
                noise                     : Background noise level. (type:uint8_t)
                remnoise                  : Remote background noise level. (type:uint8_t)
                rxerrors                  : Receive errors. (type:uint16_t)
                fixed                     : Count of error corrected packets. (type:uint16_t)

                '''
                return MAVLink_radio_message(rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed)

        def radio_send(self, rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed, force_mavlink1=False):
                '''
                Status generated by radio.

                rssi                      : Local signal strength. (type:uint8_t)
                remrssi                   : Remote signal strength. (type:uint8_t)
                txbuf                     : How full the tx buffer is. [%] (type:uint8_t)
                noise                     : Background noise level. (type:uint8_t)
                remnoise                  : Remote background noise level. (type:uint8_t)
                rxerrors                  : Receive errors. (type:uint16_t)
                fixed                     : Count of error corrected packets. (type:uint16_t)

                '''
                return self.send(self.radio_encode(rssi, remrssi, txbuf, noise, remnoise, rxerrors, fixed), force_mavlink1=force_mavlink1)

        def limits_status_encode(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered):
                '''
                Status of AP_Limits. Sent in extended status stream when AP_Limits is
                enabled.

                limits_state              : State of AP_Limits. (type:uint8_t, values:LIMITS_STATE)
                last_trigger              : Time (since boot) of last breach. [ms] (type:uint32_t)
                last_action               : Time (since boot) of last recovery action. [ms] (type:uint32_t)
                last_recovery             : Time (since boot) of last successful recovery. [ms] (type:uint32_t)
                last_clear                : Time (since boot) of last all-clear. [ms] (type:uint32_t)
                breach_count              : Number of fence breaches. (type:uint16_t)
                mods_enabled              : AP_Limit_Module bitfield of enabled modules. (type:uint8_t, values:LIMIT_MODULE)
                mods_required             : AP_Limit_Module bitfield of required modules. (type:uint8_t, values:LIMIT_MODULE)
                mods_triggered            : AP_Limit_Module bitfield of triggered modules. (type:uint8_t, values:LIMIT_MODULE)

                '''
                return MAVLink_limits_status_message(limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered)

        def limits_status_send(self, limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered, force_mavlink1=False):
                '''
                Status of AP_Limits. Sent in extended status stream when AP_Limits is
                enabled.

                limits_state              : State of AP_Limits. (type:uint8_t, values:LIMITS_STATE)
                last_trigger              : Time (since boot) of last breach. [ms] (type:uint32_t)
                last_action               : Time (since boot) of last recovery action. [ms] (type:uint32_t)
                last_recovery             : Time (since boot) of last successful recovery. [ms] (type:uint32_t)
                last_clear                : Time (since boot) of last all-clear. [ms] (type:uint32_t)
                breach_count              : Number of fence breaches. (type:uint16_t)
                mods_enabled              : AP_Limit_Module bitfield of enabled modules. (type:uint8_t, values:LIMIT_MODULE)
                mods_required             : AP_Limit_Module bitfield of required modules. (type:uint8_t, values:LIMIT_MODULE)
                mods_triggered            : AP_Limit_Module bitfield of triggered modules. (type:uint8_t, values:LIMIT_MODULE)

                '''
                return self.send(self.limits_status_encode(limits_state, last_trigger, last_action, last_recovery, last_clear, breach_count, mods_enabled, mods_required, mods_triggered), force_mavlink1=force_mavlink1)

        def wind_encode(self, direction, speed, speed_z):
                '''
                Wind estimation.

                direction                 : Wind direction (that wind is coming from). [deg] (type:float)
                speed                     : Wind speed in ground plane. [m/s] (type:float)
                speed_z                   : Vertical wind speed. [m/s] (type:float)

                '''
                return MAVLink_wind_message(direction, speed, speed_z)

        def wind_send(self, direction, speed, speed_z, force_mavlink1=False):
                '''
                Wind estimation.

                direction                 : Wind direction (that wind is coming from). [deg] (type:float)
                speed                     : Wind speed in ground plane. [m/s] (type:float)
                speed_z                   : Vertical wind speed. [m/s] (type:float)

                '''
                return self.send(self.wind_encode(direction, speed, speed_z), force_mavlink1=force_mavlink1)

        def data16_encode(self, type, len, data):
                '''
                Data packet, size 16.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return MAVLink_data16_message(type, len, data)

        def data16_send(self, type, len, data, force_mavlink1=False):
                '''
                Data packet, size 16.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return self.send(self.data16_encode(type, len, data), force_mavlink1=force_mavlink1)

        def data32_encode(self, type, len, data):
                '''
                Data packet, size 32.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return MAVLink_data32_message(type, len, data)

        def data32_send(self, type, len, data, force_mavlink1=False):
                '''
                Data packet, size 32.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return self.send(self.data32_encode(type, len, data), force_mavlink1=force_mavlink1)

        def data64_encode(self, type, len, data):
                '''
                Data packet, size 64.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return MAVLink_data64_message(type, len, data)

        def data64_send(self, type, len, data, force_mavlink1=False):
                '''
                Data packet, size 64.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return self.send(self.data64_encode(type, len, data), force_mavlink1=force_mavlink1)

        def data96_encode(self, type, len, data):
                '''
                Data packet, size 96.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return MAVLink_data96_message(type, len, data)

        def data96_send(self, type, len, data, force_mavlink1=False):
                '''
                Data packet, size 96.

                type                      : Data type. (type:uint8_t)
                len                       : Data length. [bytes] (type:uint8_t)
                data                      : Raw data. (type:uint8_t)

                '''
                return self.send(self.data96_encode(type, len, data), force_mavlink1=force_mavlink1)

        def rangefinder_encode(self, distance, voltage):
                '''
                Rangefinder reporting.

                distance                  : Distance. [m] (type:float)
                voltage                   : Raw voltage if available, zero otherwise. [V] (type:float)

                '''
                return MAVLink_rangefinder_message(distance, voltage)

        def rangefinder_send(self, distance, voltage, force_mavlink1=False):
                '''
                Rangefinder reporting.

                distance                  : Distance. [m] (type:float)
                voltage                   : Raw voltage if available, zero otherwise. [V] (type:float)

                '''
                return self.send(self.rangefinder_encode(distance, voltage), force_mavlink1=force_mavlink1)

        def airspeed_autocal_encode(self, vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz):
                '''
                Airspeed auto-calibration.

                vx                        : GPS velocity north. [m/s] (type:float)
                vy                        : GPS velocity east. [m/s] (type:float)
                vz                        : GPS velocity down. [m/s] (type:float)
                diff_pressure             : Differential pressure. [Pa] (type:float)
                EAS2TAS                   : Estimated to true airspeed ratio. (type:float)
                ratio                     : Airspeed ratio. (type:float)
                state_x                   : EKF state x. (type:float)
                state_y                   : EKF state y. (type:float)
                state_z                   : EKF state z. (type:float)
                Pax                       : EKF Pax. (type:float)
                Pby                       : EKF Pby. (type:float)
                Pcz                       : EKF Pcz. (type:float)

                '''
                return MAVLink_airspeed_autocal_message(vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz)

        def airspeed_autocal_send(self, vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz, force_mavlink1=False):
                '''
                Airspeed auto-calibration.

                vx                        : GPS velocity north. [m/s] (type:float)
                vy                        : GPS velocity east. [m/s] (type:float)
                vz                        : GPS velocity down. [m/s] (type:float)
                diff_pressure             : Differential pressure. [Pa] (type:float)
                EAS2TAS                   : Estimated to true airspeed ratio. (type:float)
                ratio                     : Airspeed ratio. (type:float)
                state_x                   : EKF state x. (type:float)
                state_y                   : EKF state y. (type:float)
                state_z                   : EKF state z. (type:float)
                Pax                       : EKF Pax. (type:float)
                Pby                       : EKF Pby. (type:float)
                Pcz                       : EKF Pcz. (type:float)

                '''
                return self.send(self.airspeed_autocal_encode(vx, vy, vz, diff_pressure, EAS2TAS, ratio, state_x, state_y, state_z, Pax, Pby, Pcz), force_mavlink1=force_mavlink1)

        def rally_point_encode(self, target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags):
                '''
                A rally point. Used to set a point when from GCS -> MAV. Also used to
                return a point from MAV -> GCS.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 0). (type:uint8_t)
                count                     : Total number of points (for sanity checking). (type:uint8_t)
                lat                       : Latitude of point. [degE7] (type:int32_t)
                lng                       : Longitude of point. [degE7] (type:int32_t)
                alt                       : Transit / loiter altitude relative to home. [m] (type:int16_t)
                break_alt                 : Break altitude relative to home. [m] (type:int16_t)
                land_dir                  : Heading to aim for when landing. [cdeg] (type:uint16_t)
                flags                     : Configuration flags. (type:uint8_t, values:RALLY_FLAGS)

                '''
                return MAVLink_rally_point_message(target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags)

        def rally_point_send(self, target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags, force_mavlink1=False):
                '''
                A rally point. Used to set a point when from GCS -> MAV. Also used to
                return a point from MAV -> GCS.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 0). (type:uint8_t)
                count                     : Total number of points (for sanity checking). (type:uint8_t)
                lat                       : Latitude of point. [degE7] (type:int32_t)
                lng                       : Longitude of point. [degE7] (type:int32_t)
                alt                       : Transit / loiter altitude relative to home. [m] (type:int16_t)
                break_alt                 : Break altitude relative to home. [m] (type:int16_t)
                land_dir                  : Heading to aim for when landing. [cdeg] (type:uint16_t)
                flags                     : Configuration flags. (type:uint8_t, values:RALLY_FLAGS)

                '''
                return self.send(self.rally_point_encode(target_system, target_component, idx, count, lat, lng, alt, break_alt, land_dir, flags), force_mavlink1=force_mavlink1)

        def rally_fetch_point_encode(self, target_system, target_component, idx):
                '''
                Request a current rally point from MAV. MAV should respond with a
                RALLY_POINT message. MAV should not respond if the
                request is invalid.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 0). (type:uint8_t)

                '''
                return MAVLink_rally_fetch_point_message(target_system, target_component, idx)

        def rally_fetch_point_send(self, target_system, target_component, idx, force_mavlink1=False):
                '''
                Request a current rally point from MAV. MAV should respond with a
                RALLY_POINT message. MAV should not respond if the
                request is invalid.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                idx                       : Point index (first point is 0). (type:uint8_t)

                '''
                return self.send(self.rally_fetch_point_encode(target_system, target_component, idx), force_mavlink1=force_mavlink1)

        def compassmot_status_encode(self, throttle, current, interference, CompensationX, CompensationY, CompensationZ):
                '''
                Status of compassmot calibration.

                throttle                  : Throttle. [d%] (type:uint16_t)
                current                   : Current. [A] (type:float)
                interference              : Interference. [%] (type:uint16_t)
                CompensationX             : Motor Compensation X. (type:float)
                CompensationY             : Motor Compensation Y. (type:float)
                CompensationZ             : Motor Compensation Z. (type:float)

                '''
                return MAVLink_compassmot_status_message(throttle, current, interference, CompensationX, CompensationY, CompensationZ)

        def compassmot_status_send(self, throttle, current, interference, CompensationX, CompensationY, CompensationZ, force_mavlink1=False):
                '''
                Status of compassmot calibration.

                throttle                  : Throttle. [d%] (type:uint16_t)
                current                   : Current. [A] (type:float)
                interference              : Interference. [%] (type:uint16_t)
                CompensationX             : Motor Compensation X. (type:float)
                CompensationY             : Motor Compensation Y. (type:float)
                CompensationZ             : Motor Compensation Z. (type:float)

                '''
                return self.send(self.compassmot_status_encode(throttle, current, interference, CompensationX, CompensationY, CompensationZ), force_mavlink1=force_mavlink1)

        def ahrs2_encode(self, roll, pitch, yaw, altitude, lat, lng):
                '''
                Status of secondary AHRS filter if available.

                roll                      : Roll angle. [rad] (type:float)
                pitch                     : Pitch angle. [rad] (type:float)
                yaw                       : Yaw angle. [rad] (type:float)
                altitude                  : Altitude (MSL). [m] (type:float)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)

                '''
                return MAVLink_ahrs2_message(roll, pitch, yaw, altitude, lat, lng)

        def ahrs2_send(self, roll, pitch, yaw, altitude, lat, lng, force_mavlink1=False):
                '''
                Status of secondary AHRS filter if available.

                roll                      : Roll angle. [rad] (type:float)
                pitch                     : Pitch angle. [rad] (type:float)
                yaw                       : Yaw angle. [rad] (type:float)
                altitude                  : Altitude (MSL). [m] (type:float)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)

                '''
                return self.send(self.ahrs2_encode(roll, pitch, yaw, altitude, lat, lng), force_mavlink1=force_mavlink1)

        def camera_status_encode(self, time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4):
                '''
                Camera Event.

                time_usec                 : Image timestamp (since UNIX epoch, according to camera clock). [us] (type:uint64_t)
                target_system             : System ID. (type:uint8_t)
                cam_idx                   : Camera ID. (type:uint8_t)
                img_idx                   : Image index. (type:uint16_t)
                event_id                  : Event type. (type:uint8_t, values:CAMERA_STATUS_TYPES)
                p1                        : Parameter 1 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)
                p2                        : Parameter 2 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)
                p3                        : Parameter 3 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)
                p4                        : Parameter 4 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)

                '''
                return MAVLink_camera_status_message(time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4)

        def camera_status_send(self, time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4, force_mavlink1=False):
                '''
                Camera Event.

                time_usec                 : Image timestamp (since UNIX epoch, according to camera clock). [us] (type:uint64_t)
                target_system             : System ID. (type:uint8_t)
                cam_idx                   : Camera ID. (type:uint8_t)
                img_idx                   : Image index. (type:uint16_t)
                event_id                  : Event type. (type:uint8_t, values:CAMERA_STATUS_TYPES)
                p1                        : Parameter 1 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)
                p2                        : Parameter 2 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)
                p3                        : Parameter 3 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)
                p4                        : Parameter 4 (meaning depends on event_id, see CAMERA_STATUS_TYPES enum). (type:float)

                '''
                return self.send(self.camera_status_encode(time_usec, target_system, cam_idx, img_idx, event_id, p1, p2, p3, p4), force_mavlink1=force_mavlink1)

        def camera_feedback_encode(self, time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags):
                '''
                Camera Capture Feedback.

                time_usec                 : Image timestamp (since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB). [us] (type:uint64_t)
                target_system             : System ID. (type:uint8_t)
                cam_idx                   : Camera ID. (type:uint8_t)
                img_idx                   : Image index. (type:uint16_t)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)
                alt_msl                   : Altitude (MSL). [m] (type:float)
                alt_rel                   : Altitude (Relative to HOME location). [m] (type:float)
                roll                      : Camera Roll angle (earth frame, +-180). [deg] (type:float)
                pitch                     : Camera Pitch angle (earth frame, +-180). [deg] (type:float)
                yaw                       : Camera Yaw (earth frame, 0-360, true). [deg] (type:float)
                foc_len                   : Focal Length. [mm] (type:float)
                flags                     : Feedback flags. (type:uint8_t, values:CAMERA_FEEDBACK_FLAGS)

                '''
                return MAVLink_camera_feedback_message(time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags)

        def camera_feedback_send(self, time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags, force_mavlink1=False):
                '''
                Camera Capture Feedback.

                time_usec                 : Image timestamp (since UNIX epoch), as passed in by CAMERA_STATUS message (or autopilot if no CCB). [us] (type:uint64_t)
                target_system             : System ID. (type:uint8_t)
                cam_idx                   : Camera ID. (type:uint8_t)
                img_idx                   : Image index. (type:uint16_t)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)
                alt_msl                   : Altitude (MSL). [m] (type:float)
                alt_rel                   : Altitude (Relative to HOME location). [m] (type:float)
                roll                      : Camera Roll angle (earth frame, +-180). [deg] (type:float)
                pitch                     : Camera Pitch angle (earth frame, +-180). [deg] (type:float)
                yaw                       : Camera Yaw (earth frame, 0-360, true). [deg] (type:float)
                foc_len                   : Focal Length. [mm] (type:float)
                flags                     : Feedback flags. (type:uint8_t, values:CAMERA_FEEDBACK_FLAGS)

                '''
                return self.send(self.camera_feedback_encode(time_usec, target_system, cam_idx, img_idx, lat, lng, alt_msl, alt_rel, roll, pitch, yaw, foc_len, flags), force_mavlink1=force_mavlink1)

        def battery2_encode(self, voltage, current_battery):
                '''
                2nd Battery status

                voltage                   : Voltage. [mV] (type:uint16_t)
                current_battery           : Battery current, -1: autopilot does not measure the current. [cA] (type:int16_t)

                '''
                return MAVLink_battery2_message(voltage, current_battery)

        def battery2_send(self, voltage, current_battery, force_mavlink1=False):
                '''
                2nd Battery status

                voltage                   : Voltage. [mV] (type:uint16_t)
                current_battery           : Battery current, -1: autopilot does not measure the current. [cA] (type:int16_t)

                '''
                return self.send(self.battery2_encode(voltage, current_battery), force_mavlink1=force_mavlink1)

        def ahrs3_encode(self, roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4):
                '''
                Status of third AHRS filter if available. This is for ANU research
                group (Ali and Sean).

                roll                      : Roll angle. [rad] (type:float)
                pitch                     : Pitch angle. [rad] (type:float)
                yaw                       : Yaw angle. [rad] (type:float)
                altitude                  : Altitude (MSL). [m] (type:float)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)
                v1                        : Test variable1. (type:float)
                v2                        : Test variable2. (type:float)
                v3                        : Test variable3. (type:float)
                v4                        : Test variable4. (type:float)

                '''
                return MAVLink_ahrs3_message(roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4)

        def ahrs3_send(self, roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4, force_mavlink1=False):
                '''
                Status of third AHRS filter if available. This is for ANU research
                group (Ali and Sean).

                roll                      : Roll angle. [rad] (type:float)
                pitch                     : Pitch angle. [rad] (type:float)
                yaw                       : Yaw angle. [rad] (type:float)
                altitude                  : Altitude (MSL). [m] (type:float)
                lat                       : Latitude. [degE7] (type:int32_t)
                lng                       : Longitude. [degE7] (type:int32_t)
                v1                        : Test variable1. (type:float)
                v2                        : Test variable2. (type:float)
                v3                        : Test variable3. (type:float)
                v4                        : Test variable4. (type:float)

                '''
                return self.send(self.ahrs3_encode(roll, pitch, yaw, altitude, lat, lng, v1, v2, v3, v4), force_mavlink1=force_mavlink1)

        def autopilot_version_request_encode(self, target_system, target_component):
                '''
                Request the autopilot version from the system/component.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)

                '''
                return MAVLink_autopilot_version_request_message(target_system, target_component)

        def autopilot_version_request_send(self, target_system, target_component, force_mavlink1=False):
                '''
                Request the autopilot version from the system/component.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)

                '''
                return self.send(self.autopilot_version_request_encode(target_system, target_component), force_mavlink1=force_mavlink1)

        def remote_log_data_block_encode(self, target_system, target_component, seqno, data):
                '''
                Send a block of log data to remote location.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                seqno                     : Log data block sequence number. (type:uint32_t, values:MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS)
                data                      : Log data block. (type:uint8_t)

                '''
                return MAVLink_remote_log_data_block_message(target_system, target_component, seqno, data)

        def remote_log_data_block_send(self, target_system, target_component, seqno, data, force_mavlink1=False):
                '''
                Send a block of log data to remote location.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                seqno                     : Log data block sequence number. (type:uint32_t, values:MAV_REMOTE_LOG_DATA_BLOCK_COMMANDS)
                data                      : Log data block. (type:uint8_t)

                '''
                return self.send(self.remote_log_data_block_encode(target_system, target_component, seqno, data), force_mavlink1=force_mavlink1)

        def remote_log_block_status_encode(self, target_system, target_component, seqno, status):
                '''
                Send Status of each log block that autopilot board might have sent.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                seqno                     : Log data block sequence number. (type:uint32_t)
                status                    : Log data block status. (type:uint8_t, values:MAV_REMOTE_LOG_DATA_BLOCK_STATUSES)

                '''
                return MAVLink_remote_log_block_status_message(target_system, target_component, seqno, status)

        def remote_log_block_status_send(self, target_system, target_component, seqno, status, force_mavlink1=False):
                '''
                Send Status of each log block that autopilot board might have sent.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                seqno                     : Log data block sequence number. (type:uint32_t)
                status                    : Log data block status. (type:uint8_t, values:MAV_REMOTE_LOG_DATA_BLOCK_STATUSES)

                '''
                return self.send(self.remote_log_block_status_encode(target_system, target_component, seqno, status), force_mavlink1=force_mavlink1)

        def led_control_encode(self, target_system, target_component, instance, pattern, custom_len, custom_bytes):
                '''
                Control vehicle LEDs.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                instance                  : Instance (LED instance to control or 255 for all LEDs). (type:uint8_t)
                pattern                   : Pattern (see LED_PATTERN_ENUM). (type:uint8_t)
                custom_len                : Custom Byte Length. (type:uint8_t)
                custom_bytes              : Custom Bytes. (type:uint8_t)

                '''
                return MAVLink_led_control_message(target_system, target_component, instance, pattern, custom_len, custom_bytes)

        def led_control_send(self, target_system, target_component, instance, pattern, custom_len, custom_bytes, force_mavlink1=False):
                '''
                Control vehicle LEDs.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                instance                  : Instance (LED instance to control or 255 for all LEDs). (type:uint8_t)
                pattern                   : Pattern (see LED_PATTERN_ENUM). (type:uint8_t)
                custom_len                : Custom Byte Length. (type:uint8_t)
                custom_bytes              : Custom Bytes. (type:uint8_t)

                '''
                return self.send(self.led_control_encode(target_system, target_component, instance, pattern, custom_len, custom_bytes), force_mavlink1=force_mavlink1)

        def mag_cal_progress_encode(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z):
                '''
                Reports progress of compass calibration.

                compass_id                : Compass being calibrated. (type:uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated. (type:uint8_t)
                cal_status                : Calibration Status. (type:uint8_t, values:MAG_CAL_STATUS)
                attempt                   : Attempt number. (type:uint8_t)
                completion_pct            : Completion percentage. [%] (type:uint8_t)
                completion_mask           : Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid). (type:uint8_t)
                direction_x               : Body frame direction vector for display. (type:float)
                direction_y               : Body frame direction vector for display. (type:float)
                direction_z               : Body frame direction vector for display. (type:float)

                '''
                return MAVLink_mag_cal_progress_message(compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z)

        def mag_cal_progress_send(self, compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z, force_mavlink1=False):
                '''
                Reports progress of compass calibration.

                compass_id                : Compass being calibrated. (type:uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated. (type:uint8_t)
                cal_status                : Calibration Status. (type:uint8_t, values:MAG_CAL_STATUS)
                attempt                   : Attempt number. (type:uint8_t)
                completion_pct            : Completion percentage. [%] (type:uint8_t)
                completion_mask           : Bitmask of sphere sections (see http://en.wikipedia.org/wiki/Geodesic_grid). (type:uint8_t)
                direction_x               : Body frame direction vector for display. (type:float)
                direction_y               : Body frame direction vector for display. (type:float)
                direction_z               : Body frame direction vector for display. (type:float)

                '''
                return self.send(self.mag_cal_progress_encode(compass_id, cal_mask, cal_status, attempt, completion_pct, completion_mask, direction_x, direction_y, direction_z), force_mavlink1=force_mavlink1)

        def mag_cal_report_encode(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z):
                '''
                Reports results of completed compass calibration. Sent until
                MAG_CAL_ACK received.

                compass_id                : Compass being calibrated. (type:uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated. (type:uint8_t)
                cal_status                : Calibration Status. (type:uint8_t, values:MAG_CAL_STATUS)
                autosaved                 : 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters. (type:uint8_t)
                fitness                   : RMS milligauss residuals. [mgauss] (type:float)
                ofs_x                     : X offset. (type:float)
                ofs_y                     : Y offset. (type:float)
                ofs_z                     : Z offset. (type:float)
                diag_x                    : X diagonal (matrix 11). (type:float)
                diag_y                    : Y diagonal (matrix 22). (type:float)
                diag_z                    : Z diagonal (matrix 33). (type:float)
                offdiag_x                 : X off-diagonal (matrix 12 and 21). (type:float)
                offdiag_y                 : Y off-diagonal (matrix 13 and 31). (type:float)
                offdiag_z                 : Z off-diagonal (matrix 32 and 23). (type:float)

                '''
                return MAVLink_mag_cal_report_message(compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z)

        def mag_cal_report_send(self, compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z, force_mavlink1=False):
                '''
                Reports results of completed compass calibration. Sent until
                MAG_CAL_ACK received.

                compass_id                : Compass being calibrated. (type:uint8_t)
                cal_mask                  : Bitmask of compasses being calibrated. (type:uint8_t)
                cal_status                : Calibration Status. (type:uint8_t, values:MAG_CAL_STATUS)
                autosaved                 : 0=requires a MAV_CMD_DO_ACCEPT_MAG_CAL, 1=saved to parameters. (type:uint8_t)
                fitness                   : RMS milligauss residuals. [mgauss] (type:float)
                ofs_x                     : X offset. (type:float)
                ofs_y                     : Y offset. (type:float)
                ofs_z                     : Z offset. (type:float)
                diag_x                    : X diagonal (matrix 11). (type:float)
                diag_y                    : Y diagonal (matrix 22). (type:float)
                diag_z                    : Z diagonal (matrix 33). (type:float)
                offdiag_x                 : X off-diagonal (matrix 12 and 21). (type:float)
                offdiag_y                 : Y off-diagonal (matrix 13 and 31). (type:float)
                offdiag_z                 : Z off-diagonal (matrix 32 and 23). (type:float)

                '''
                return self.send(self.mag_cal_report_encode(compass_id, cal_mask, cal_status, autosaved, fitness, ofs_x, ofs_y, ofs_z, diag_x, diag_y, diag_z, offdiag_x, offdiag_y, offdiag_z), force_mavlink1=force_mavlink1)

        def ekf_status_report_encode(self, flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance):
                '''
                EKF Status message including flags and variances.

                flags                     : Flags. (type:uint16_t, values:EKF_STATUS_FLAGS)
                velocity_variance         : Velocity variance. (type:float)
                pos_horiz_variance        : Horizontal Position variance. (type:float)
                pos_vert_variance         : Vertical Position variance. (type:float)
                compass_variance          : Compass variance. (type:float)
                terrain_alt_variance        : Terrain Altitude variance. (type:float)

                '''
                return MAVLink_ekf_status_report_message(flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance)

        def ekf_status_report_send(self, flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance, force_mavlink1=False):
                '''
                EKF Status message including flags and variances.

                flags                     : Flags. (type:uint16_t, values:EKF_STATUS_FLAGS)
                velocity_variance         : Velocity variance. (type:float)
                pos_horiz_variance        : Horizontal Position variance. (type:float)
                pos_vert_variance         : Vertical Position variance. (type:float)
                compass_variance          : Compass variance. (type:float)
                terrain_alt_variance        : Terrain Altitude variance. (type:float)

                '''
                return self.send(self.ekf_status_report_encode(flags, velocity_variance, pos_horiz_variance, pos_vert_variance, compass_variance, terrain_alt_variance), force_mavlink1=force_mavlink1)

        def pid_tuning_encode(self, axis, desired, achieved, FF, P, I, D):
                '''
                PID tuning information.

                axis                      : Axis. (type:uint8_t, values:PID_TUNING_AXIS)
                desired                   : Desired rate. [deg/s] (type:float)
                achieved                  : Achieved rate. [deg/s] (type:float)
                FF                        : FF component. (type:float)
                P                         : P component. (type:float)
                I                         : I component. (type:float)
                D                         : D component. (type:float)

                '''
                return MAVLink_pid_tuning_message(axis, desired, achieved, FF, P, I, D)

        def pid_tuning_send(self, axis, desired, achieved, FF, P, I, D, force_mavlink1=False):
                '''
                PID tuning information.

                axis                      : Axis. (type:uint8_t, values:PID_TUNING_AXIS)
                desired                   : Desired rate. [deg/s] (type:float)
                achieved                  : Achieved rate. [deg/s] (type:float)
                FF                        : FF component. (type:float)
                P                         : P component. (type:float)
                I                         : I component. (type:float)
                D                         : D component. (type:float)

                '''
                return self.send(self.pid_tuning_encode(axis, desired, achieved, FF, P, I, D), force_mavlink1=force_mavlink1)

        def deepstall_encode(self, landing_lat, landing_lon, path_lat, path_lon, arc_entry_lat, arc_entry_lon, altitude, expected_travel_distance, cross_track_error, stage):
                '''
                Deepstall path planning.

                landing_lat               : Landing latitude. [degE7] (type:int32_t)
                landing_lon               : Landing longitude. [degE7] (type:int32_t)
                path_lat                  : Final heading start point, latitude. [degE7] (type:int32_t)
                path_lon                  : Final heading start point, longitude. [degE7] (type:int32_t)
                arc_entry_lat             : Arc entry point, latitude. [degE7] (type:int32_t)
                arc_entry_lon             : Arc entry point, longitude. [degE7] (type:int32_t)
                altitude                  : Altitude. [m] (type:float)
                expected_travel_distance        : Distance the aircraft expects to travel during the deepstall. [m] (type:float)
                cross_track_error         : Deepstall cross track error (only valid when in DEEPSTALL_STAGE_LAND). [m] (type:float)
                stage                     : Deepstall stage. (type:uint8_t, values:DEEPSTALL_STAGE)

                '''
                return MAVLink_deepstall_message(landing_lat, landing_lon, path_lat, path_lon, arc_entry_lat, arc_entry_lon, altitude, expected_travel_distance, cross_track_error, stage)

        def deepstall_send(self, landing_lat, landing_lon, path_lat, path_lon, arc_entry_lat, arc_entry_lon, altitude, expected_travel_distance, cross_track_error, stage, force_mavlink1=False):
                '''
                Deepstall path planning.

                landing_lat               : Landing latitude. [degE7] (type:int32_t)
                landing_lon               : Landing longitude. [degE7] (type:int32_t)
                path_lat                  : Final heading start point, latitude. [degE7] (type:int32_t)
                path_lon                  : Final heading start point, longitude. [degE7] (type:int32_t)
                arc_entry_lat             : Arc entry point, latitude. [degE7] (type:int32_t)
                arc_entry_lon             : Arc entry point, longitude. [degE7] (type:int32_t)
                altitude                  : Altitude. [m] (type:float)
                expected_travel_distance        : Distance the aircraft expects to travel during the deepstall. [m] (type:float)
                cross_track_error         : Deepstall cross track error (only valid when in DEEPSTALL_STAGE_LAND). [m] (type:float)
                stage                     : Deepstall stage. (type:uint8_t, values:DEEPSTALL_STAGE)

                '''
                return self.send(self.deepstall_encode(landing_lat, landing_lon, path_lat, path_lon, arc_entry_lat, arc_entry_lon, altitude, expected_travel_distance, cross_track_error, stage), force_mavlink1=force_mavlink1)

        def gimbal_report_encode(self, target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az):
                '''
                3 axis gimbal measurements.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                delta_time                : Time since last update. [s] (type:float)
                delta_angle_x             : Delta angle X. [rad] (type:float)
                delta_angle_y             : Delta angle Y. [rad] (type:float)
                delta_angle_z             : Delta angle X. [rad] (type:float)
                delta_velocity_x          : Delta velocity X. [m/s] (type:float)
                delta_velocity_y          : Delta velocity Y. [m/s] (type:float)
                delta_velocity_z          : Delta velocity Z. [m/s] (type:float)
                joint_roll                : Joint ROLL. [rad] (type:float)
                joint_el                  : Joint EL. [rad] (type:float)
                joint_az                  : Joint AZ. [rad] (type:float)

                '''
                return MAVLink_gimbal_report_message(target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az)

        def gimbal_report_send(self, target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az, force_mavlink1=False):
                '''
                3 axis gimbal measurements.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                delta_time                : Time since last update. [s] (type:float)
                delta_angle_x             : Delta angle X. [rad] (type:float)
                delta_angle_y             : Delta angle Y. [rad] (type:float)
                delta_angle_z             : Delta angle X. [rad] (type:float)
                delta_velocity_x          : Delta velocity X. [m/s] (type:float)
                delta_velocity_y          : Delta velocity Y. [m/s] (type:float)
                delta_velocity_z          : Delta velocity Z. [m/s] (type:float)
                joint_roll                : Joint ROLL. [rad] (type:float)
                joint_el                  : Joint EL. [rad] (type:float)
                joint_az                  : Joint AZ. [rad] (type:float)

                '''
                return self.send(self.gimbal_report_encode(target_system, target_component, delta_time, delta_angle_x, delta_angle_y, delta_angle_z, delta_velocity_x, delta_velocity_y, delta_velocity_z, joint_roll, joint_el, joint_az), force_mavlink1=force_mavlink1)

        def gimbal_control_encode(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z):
                '''
                Control message for rate gimbal.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                demanded_rate_x           : Demanded angular rate X. [rad/s] (type:float)
                demanded_rate_y           : Demanded angular rate Y. [rad/s] (type:float)
                demanded_rate_z           : Demanded angular rate Z. [rad/s] (type:float)

                '''
                return MAVLink_gimbal_control_message(target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z)

        def gimbal_control_send(self, target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z, force_mavlink1=False):
                '''
                Control message for rate gimbal.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                demanded_rate_x           : Demanded angular rate X. [rad/s] (type:float)
                demanded_rate_y           : Demanded angular rate Y. [rad/s] (type:float)
                demanded_rate_z           : Demanded angular rate Z. [rad/s] (type:float)

                '''
                return self.send(self.gimbal_control_encode(target_system, target_component, demanded_rate_x, demanded_rate_y, demanded_rate_z), force_mavlink1=force_mavlink1)

        def gimbal_torque_cmd_report_encode(self, target_system, target_component, rl_torque_cmd, el_torque_cmd, az_torque_cmd):
                '''
                100 Hz gimbal torque command telemetry.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                rl_torque_cmd             : Roll Torque Command. (type:int16_t)
                el_torque_cmd             : Elevation Torque Command. (type:int16_t)
                az_torque_cmd             : Azimuth Torque Command. (type:int16_t)

                '''
                return MAVLink_gimbal_torque_cmd_report_message(target_system, target_component, rl_torque_cmd, el_torque_cmd, az_torque_cmd)

        def gimbal_torque_cmd_report_send(self, target_system, target_component, rl_torque_cmd, el_torque_cmd, az_torque_cmd, force_mavlink1=False):
                '''
                100 Hz gimbal torque command telemetry.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                rl_torque_cmd             : Roll Torque Command. (type:int16_t)
                el_torque_cmd             : Elevation Torque Command. (type:int16_t)
                az_torque_cmd             : Azimuth Torque Command. (type:int16_t)

                '''
                return self.send(self.gimbal_torque_cmd_report_encode(target_system, target_component, rl_torque_cmd, el_torque_cmd, az_torque_cmd), force_mavlink1=force_mavlink1)

        def gopro_heartbeat_encode(self, status, capture_mode, flags):
                '''
                Heartbeat from a HeroBus attached GoPro.

                status                    : Status. (type:uint8_t, values:GOPRO_HEARTBEAT_STATUS)
                capture_mode              : Current capture mode. (type:uint8_t, values:GOPRO_CAPTURE_MODE)
                flags                     : Additional status bits. (type:uint8_t, values:GOPRO_HEARTBEAT_FLAGS)

                '''
                return MAVLink_gopro_heartbeat_message(status, capture_mode, flags)

        def gopro_heartbeat_send(self, status, capture_mode, flags, force_mavlink1=False):
                '''
                Heartbeat from a HeroBus attached GoPro.

                status                    : Status. (type:uint8_t, values:GOPRO_HEARTBEAT_STATUS)
                capture_mode              : Current capture mode. (type:uint8_t, values:GOPRO_CAPTURE_MODE)
                flags                     : Additional status bits. (type:uint8_t, values:GOPRO_HEARTBEAT_FLAGS)

                '''
                return self.send(self.gopro_heartbeat_encode(status, capture_mode, flags), force_mavlink1=force_mavlink1)

        def gopro_get_request_encode(self, target_system, target_component, cmd_id):
                '''
                Request a GOPRO_COMMAND response from the GoPro.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)

                '''
                return MAVLink_gopro_get_request_message(target_system, target_component, cmd_id)

        def gopro_get_request_send(self, target_system, target_component, cmd_id, force_mavlink1=False):
                '''
                Request a GOPRO_COMMAND response from the GoPro.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)

                '''
                return self.send(self.gopro_get_request_encode(target_system, target_component, cmd_id), force_mavlink1=force_mavlink1)

        def gopro_get_response_encode(self, cmd_id, status, value):
                '''
                Response from a GOPRO_COMMAND get request.

                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)
                status                    : Status. (type:uint8_t, values:GOPRO_REQUEST_STATUS)
                value                     : Value. (type:uint8_t)

                '''
                return MAVLink_gopro_get_response_message(cmd_id, status, value)

        def gopro_get_response_send(self, cmd_id, status, value, force_mavlink1=False):
                '''
                Response from a GOPRO_COMMAND get request.

                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)
                status                    : Status. (type:uint8_t, values:GOPRO_REQUEST_STATUS)
                value                     : Value. (type:uint8_t)

                '''
                return self.send(self.gopro_get_response_encode(cmd_id, status, value), force_mavlink1=force_mavlink1)

        def gopro_set_request_encode(self, target_system, target_component, cmd_id, value):
                '''
                Request to set a GOPRO_COMMAND with a desired.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)
                value                     : Value. (type:uint8_t)

                '''
                return MAVLink_gopro_set_request_message(target_system, target_component, cmd_id, value)

        def gopro_set_request_send(self, target_system, target_component, cmd_id, value, force_mavlink1=False):
                '''
                Request to set a GOPRO_COMMAND with a desired.

                target_system             : System ID. (type:uint8_t)
                target_component          : Component ID. (type:uint8_t)
                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)
                value                     : Value. (type:uint8_t)

                '''
                return self.send(self.gopro_set_request_encode(target_system, target_component, cmd_id, value), force_mavlink1=force_mavlink1)

        def gopro_set_response_encode(self, cmd_id, status):
                '''
                Response from a GOPRO_COMMAND set request.

                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)
                status                    : Status. (type:uint8_t, values:GOPRO_REQUEST_STATUS)

                '''
                return MAVLink_gopro_set_response_message(cmd_id, status)

        def gopro_set_response_send(self, cmd_id, status, force_mavlink1=False):
                '''
                Response from a GOPRO_COMMAND set request.

                cmd_id                    : Command ID. (type:uint8_t, values:GOPRO_COMMAND)
                status                    : Status. (type:uint8_t, values:GOPRO_REQUEST_STATUS)

                '''
                return self.send(self.gopro_set_response_encode(cmd_id, status), force_mavlink1=force_mavlink1)

        def efi_status_encode(self, health, ecu_index, rpm, fuel_consumed, fuel_flow, engine_load, throttle_position, spark_dwell_time, barometric_pressure, intake_manifold_pressure, intake_manifold_temperature, cylinder_head_temperature, ignition_timing, injection_time, exhaust_gas_temperature, throttle_out, pt_compensation):
                '''
                EFI status output

                health                    : EFI health status (type:uint8_t)
                ecu_index                 : ECU index (type:float)
                rpm                       : RPM (type:float)
                fuel_consumed             : Fuel consumed [g] (type:float)
                fuel_flow                 : Fuel flow rate [g/min] (type:float)
                engine_load               : Engine load [%] (type:float)
                throttle_position         : Throttle position [%] (type:float)
                spark_dwell_time          : Spark dwell time [ms] (type:float)
                barometric_pressure        : Barometric pressure [kPa] (type:float)
                intake_manifold_pressure        : Intake manifold pressure( [kPa] (type:float)
                intake_manifold_temperature        : Intake manifold temperature [degC] (type:float)
                cylinder_head_temperature        : Cylinder head temperature [degC] (type:float)
                ignition_timing           : Ignition timing (Crank angle degrees) [deg] (type:float)
                injection_time            : Injection time [ms] (type:float)
                exhaust_gas_temperature        : Exhaust gas temperature [degC] (type:float)
                throttle_out              : Output throttle [%] (type:float)
                pt_compensation           : Pressure/temperature compensation (type:float)

                '''
                return MAVLink_efi_status_message(health, ecu_index, rpm, fuel_consumed, fuel_flow, engine_load, throttle_position, spark_dwell_time, barometric_pressure, intake_manifold_pressure, intake_manifold_temperature, cylinder_head_temperature, ignition_timing, injection_time, exhaust_gas_temperature, throttle_out, pt_compensation)

        def efi_status_send(self, health, ecu_index, rpm, fuel_consumed, fuel_flow, engine_load, throttle_position, spark_dwell_time, barometric_pressure, intake_manifold_pressure, intake_manifold_temperature, cylinder_head_temperature, ignition_timing, injection_time, exhaust_gas_temperature, throttle_out, pt_compensation, force_mavlink1=False):
                '''
                EFI status output

                health                    : EFI health status (type:uint8_t)
                ecu_index                 : ECU index (type:float)
                rpm                       : RPM (type:float)
                fuel_consumed             : Fuel consumed [g] (type:float)
                fuel_flow                 : Fuel flow rate [g/min] (type:float)
                engine_load               : Engine load [%] (type:float)
                throttle_position         : Throttle position [%] (type:float)
                spark_dwell_time          : Spark dwell time [ms] (type:float)
                barometric_pressure        : Barometric pressure [kPa] (type:float)
                intake_manifold_pressure        : Intake manifold pressure( [kPa] (type:float)
                intake_manifold_temperature        : Intake manifold temperature [degC] (type:float)
                cylinder_head_temperature        : Cylinder head temperature [degC] (type:float)
                ignition_timing           : Ignition timing (Crank angle degrees) [deg] (type:float)
                injection_time            : Injection time [ms] (type:float)
                exhaust_gas_temperature        : Exhaust gas temperature [degC] (type:float)
                throttle_out              : Output throttle [%] (type:float)
                pt_compensation           : Pressure/temperature compensation (type:float)

                '''
                return self.send(self.efi_status_encode(health, ecu_index, rpm, fuel_consumed, fuel_flow, engine_load, throttle_position, spark_dwell_time, barometric_pressure, intake_manifold_pressure, intake_manifold_temperature, cylinder_head_temperature, ignition_timing, injection_time, exhaust_gas_temperature, throttle_out, pt_compensation), force_mavlink1=force_mavlink1)

        def rpm_encode(self, rpm1, rpm2):
                '''
                RPM sensor output.

                rpm1                      : RPM Sensor1. (type:float)
                rpm2                      : RPM Sensor2. (type:float)

                '''
                return MAVLink_rpm_message(rpm1, rpm2)

        def rpm_send(self, rpm1, rpm2, force_mavlink1=False):
                '''
                RPM sensor output.

                rpm1                      : RPM Sensor1. (type:float)
                rpm2                      : RPM Sensor2. (type:float)

                '''
                return self.send(self.rpm_encode(rpm1, rpm2), force_mavlink1=force_mavlink1)

